<!-- HTML header for doxygen 1.9.4-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AEM13920 Portal: HAL Driver API</title>
<link rel="shortcut icon" href="favicon.ico"/>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="../include/js/doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="../include/js/doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="../include/js/sitemap.js"></script>
<script type="text/javascript" src="../include/js/menuselect.js" defer></script>
<script type="text/javascript" src="../include/js/versionselect.js"></script>
<script type="text/javascript" src="../include/js/loading.js"></script>
<script type="text/javascript" src="../include/js/getsection.js"></script>
<script type="text/javascript" src="../include/js/treeview_fold_and_resize.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript" src="navtreedata_dic.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="../include/css/doxygen-awesome.css" rel="stylesheet" type="text/css" />
<link href="../include/css/custom-epeas.css" rel="stylesheet" type="text/css" />
<link href="custom-epeas-software.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
</script>
</head>
<body>
<script type="text/javascript" src="../include/js/navtreedata-custom.js"></script>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo">
    <svg     xmlns:dc="http://purl.org/dc/elements/1.1/"     xmlns:cc="http://creativecommons.org/ns#"     xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"     xmlns:svg="http://www.w3.org/2000/svg"     xmlns="http://www.w3.org/2000/svg"     xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"     xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"     sodipodi:docname="logo_bw.svg"     xml:space="preserve"     enable-background="new 0 0 587.5 259.99"     viewBox="0 0 434.75299 152.58501"     height="152.58501"     width="434.75299"     y="0px"     x="0px"     id="Layer_1"     version="1.1"     inkscape:version="0.92.3 (2405546, 2018-03-11)"><metadata     id="metadata4027"><rdf:RDF><cc:Work         rdf:about=""><dc:format>image/svg+xml</dc:format><dc:type           rdf:resource="http://purl.org/dc/dcmitype/StillImage" /><dc:title></dc:title></cc:Work></rdf:RDF></metadata><defs     id="defs4025"><filter       style="color-interpolation-filters:sRGB;"       inkscape:label="Greyscale"       id="filter4240"><feColorMatrix         values="0.21 0.72 0.072 0 0 0.21 0.72 0.072 0 0 0.21 0.72 0.072 0 0 0 0 0 1 0 "         id="feColorMatrix4238"         result="fbSourceGraphic" /><feColorMatrix         result="fbSourceGraphicAlpha"         in="fbSourceGraphic"         values="0 0 0 -1 0 0 0 0 -1 0 0 0 0 -1 0 0 0 0 1 0"         id="feColorMatrix4242" /><feColorMatrix         id="feColorMatrix4244"         values="0.21 0.72 0.072 0 0 0.21 0.72 0.072 0 0 0.21 0.72 0.072 0 0 0 0 0 1 0 "         in="fbSourceGraphic" /></filter></defs><sodipodi:namedview     inkscape:current-layer="Layer_1"     inkscape:window-maximized="0"     inkscape:window-y="229"     inkscape:window-x="252"     inkscape:cy="76.293002"     inkscape:cx="217.376"     inkscape:zoom="1.2476596"     fit-margin-right="20"     fit-margin-bottom="20"     fit-margin-top="20"     fit-margin-left="20"     scale-x="1"     showgrid="false"     id="namedview4023"     inkscape:window-height="631"     inkscape:window-width="991"     inkscape:pageshadow="2"     inkscape:pageopacity="0"     guidetolerance="10"     gridtolerance="10"     objecttolerance="10"     borderopacity="1"     bordercolor="#666666"     pagecolor="#ffffff" />  <g     id="g4020"     transform="translate(-76.374,-53.703)"     style="filter:url(#filter4240)">   <g     id="g3958">    <g     id="g3956">     <g     id="g3954">      <path     d="m 187.276,81.703 c 7.556,0 13.683,6.126 13.683,13.683 v 69.218 c 0,7.557 -6.127,13.684 -13.683,13.684 h -69.22 c -7.555,0 -13.682,-6.127 -13.682,-13.684 V 95.386 c 0,-7.557 6.127,-13.683 13.682,-13.683 h 69.22 m 0,-8 h -69.22 c -11.955,0 -21.682,9.727 -21.682,21.683 v 69.218 c 0,11.957 9.727,21.684 21.682,21.684 h 69.22 c 11.956,0 21.683,-9.727 21.683,-21.684 V 95.386 C 208.958,83.43 199.232,73.703 187.276,73.703 Z"     id="path3952"     inkscape:connector-curvature="0"     style="fill:#273029" />     </g>    </g>   </g>   <g     id="g3972">    <path     d="m 142.708,129.998 c 0,5.496 4.461,9.955 9.959,9.955 5.496,0 9.957,-4.459 9.957,-9.955 0,-5.504 -4.461,-9.961 -9.957,-9.961 -5.498,0 -9.959,4.457 -9.959,9.961 z"     id="path3960"     inkscape:connector-curvature="0"     style="fill:#6bbe6d" />    <g     id="g3970">     <g     id="g3964">      <path     d="m 144.181,141.053 c -3.319,-2.555 -5.473,-6.553 -5.473,-11.055 0,-7.698 6.263,-13.961 13.959,-13.961 1.757,0 3.433,0.34 4.983,0.936 4.787,-7.209 11.625,-12.777 26.948,-12.884 -1.161,-3.73 -4.642,-6.438 -8.754,-6.438 h -46.359 c -5.061,0 -9.164,4.103 -9.164,9.164 v 45.096 c 13.567,-0.007 19.505,-4.417 23.86,-10.858 z"     id="path3962"     inkscape:connector-curvature="0"     style="fill:#273029" />     </g>     <g     id="g3968">      <path     d="m 161.151,118.938 c 3.32,2.554 5.474,6.556 5.474,11.061 0,7.695 -6.261,13.955 -13.957,13.955 -1.759,0 -3.435,-0.34 -4.986,-0.938 -4.786,7.211 -11.624,12.777 -26.947,12.885 1.16,3.73 4.64,6.439 8.752,6.439 h 46.359 c 5.062,0 9.166,-4.104 9.166,-9.164 V 108.08 c -13.568,0.005 -19.507,4.415 -23.861,10.858 z"     id="path3966"     inkscape:connector-curvature="0"     style="fill:#273029" />     </g>    </g>   </g>   <g     id="g4002">    <path     d="m 326.824,172.119 c 0.064,1.092 1.264,1.592 2.398,1.592 1.156,0 2.443,-0.324 2.51,-1.611 0,-0.961 -0.982,-1.244 -2.357,-1.418 -2.16,-0.285 -4.582,-0.525 -4.648,-2.904 0,-2.246 2.184,-3.295 4.475,-3.295 2.422,0 4.539,1.068 4.473,3.164 h -2.096 c 0,-1.047 -1.264,-1.373 -2.377,-1.373 -1.092,0 -2.227,0.521 -2.16,1.463 0.021,0.869 0.871,1.066 2.51,1.264 2.205,0.283 4.342,0.654 4.342,3.141 0,2.336 -2.248,3.34 -4.582,3.34 -2.336,0 -4.648,-0.742 -4.822,-3.361 h 2.334 z"     id="path3974"     inkscape:connector-curvature="0"     style="fill:#6bbe6d" />    <path     d="m 345.764,170.396 h -7.77 c 0,1.92 1.506,3.055 3.426,3.055 1.309,0.064 2.576,-0.109 3.82,-0.654 l 0.303,1.768 c -1.221,0.545 -2.639,0.895 -3.969,0.895 -3.471,0.064 -6.023,-2.162 -5.914,-5.719 0.064,-3.512 2.596,-5.279 5.455,-5.279 3.688,-10e-4 5.346,2.442 4.649,5.934 z m -7.727,-1.679 h 5.807 c 0.064,-1.596 -1.244,-2.424 -2.75,-2.424 -1.573,0 -2.729,0.764 -3.057,2.424 z"     id="path3976"     inkscape:connector-curvature="0"     style="fill:#6bbe6d" />    <path     d="m 362.586,175.219 v -6.154 c 0.023,-1.57 -0.633,-2.684 -2.029,-2.662 -1.461,0.023 -2.443,1.068 -2.465,2.729 v 6.088 h -2.334 v -6.088 c 0,-1.637 -0.678,-2.729 -2.16,-2.705 -1.484,0.02 -2.555,1.068 -2.555,2.727 v 6.066 h -2.379 v -7.529 c 0,-1.221 -0.064,-1.615 -1.111,-1.549 l -0.023,-1.463 c 1.396,-0.35 3.361,-0.457 3.295,1.748 0.59,-1.289 2.139,-1.943 3.578,-1.943 1.834,0 2.771,0.699 3.188,1.986 0.588,-1.398 2.225,-1.986 3.84,-1.986 2.881,0 3.623,2.051 3.557,4.582 v 6.154 h -2.402 z"     id="path3978"     inkscape:connector-curvature="0"     style="fill:#6bbe6d" />    <path     d="m 369.176,160.053 c 0.719,0 1.418,0.48 1.418,1.396 0,0.939 -0.699,1.396 -1.396,1.418 -0.723,0.023 -1.463,-0.457 -1.463,-1.418 -0.001,-0.937 0.72,-1.396 1.441,-1.396 z m 1.178,15.166 h -2.379 v -10.408 h 2.379 z"     id="path3980"     inkscape:connector-curvature="0"     style="fill:#6bbe6d" />    <path     d="m 381.24,168.191 c -0.457,-1.135 -1.57,-1.68 -2.793,-1.68 -1.613,0 -3.271,1.178 -3.271,3.404 0,2.27 1.637,3.426 3.229,3.426 1.178,0 2.355,-0.633 2.836,-1.92 h 2.27 c -0.545,2.662 -2.836,3.971 -5.148,3.971 -2.75,0 -5.543,-1.832 -5.543,-5.477 0,-3.623 2.793,-5.5 5.521,-5.521 2.291,-0.02 4.537,1.223 5.105,3.797 z"     id="path3982"     inkscape:connector-curvature="0"     style="fill:#6bbe6d" />    <path     d="m 390.689,175.414 c -2.771,0 -5.543,-1.832 -5.543,-5.498 0,-3.623 2.705,-5.434 5.455,-5.477 2.814,-0.045 5.65,1.789 5.65,5.477 0.001,3.666 -2.792,5.498 -5.562,5.498 z m 0.043,-2.094 c 1.572,-0.023 3.143,-1.156 3.143,-3.404 0,-2.291 -1.658,-3.426 -3.273,-3.383 -1.572,0.045 -3.1,1.156 -3.1,3.383 0,2.291 1.615,3.426 3.23,3.404 z"     id="path3984"     inkscape:connector-curvature="0"     style="fill:#6bbe6d" />    <path     d="m 406.574,175.219 v -6.174 c 0.021,-1.637 -1.047,-2.643 -2.467,-2.664 -1.482,0 -2.662,1.156 -2.662,2.859 v 5.979 h -2.4 v -7.463 c 0,-1.244 -0.043,-1.592 -1.113,-1.527 v -1.551 c 1.527,-0.283 3.297,-0.371 3.297,1.637 0.588,-1.33 2.203,-1.832 3.578,-1.832 2.857,0 4.168,1.963 4.168,4.562 v 6.174 z"     id="path3986"     inkscape:connector-curvature="0"     style="fill:#6bbe6d" />    <path     d="m 419.6,173.297 c -0.697,1.549 -1.941,2.141 -3.49,2.141 -3.143,0.064 -4.846,-2.555 -4.846,-5.5 0,-3.252 2.27,-5.389 4.977,-5.389 0.938,0 1.965,0.24 2.924,0.807 v -6.111 h 2.379 v 12.701 c 0,1.201 -0.109,1.658 1.092,1.658 l 0.043,1.637 c -1.637,0.283 -3.078,0.133 -3.078,-1.637 v -0.307 z m -0.393,-5.848 c -0.852,-0.588 -1.766,-0.85 -2.596,-0.828 -1.637,0.021 -2.99,1.178 -2.99,3.316 0,1.812 0.916,3.383 2.859,3.383 1.637,0 2.727,-1.332 2.727,-2.924 z"     id="path3988"     inkscape:connector-curvature="0"     style="fill:#6bbe6d" />    <path     d="m 434.635,164.701 v 7.506 c 0,1.266 0.109,1.615 1.111,1.504 l 0.023,1.551 c -1.352,0.24 -3.273,0.525 -3.273,-1.746 -0.721,1.418 -2.16,1.877 -3.645,1.877 -2.902,0 -3.926,-2.029 -3.926,-4.604 v -6.088 h 2.398 v 6.088 c -0.021,1.68 0.871,2.705 2.27,2.705 1.506,0 2.662,-1.092 2.662,-2.77 v -6.023 z"     id="path3990"     inkscape:connector-curvature="0"     style="fill:#6bbe6d" />    <path     d="m 445.85,168.191 c -0.457,-1.135 -1.57,-1.68 -2.793,-1.68 -1.613,0 -3.273,1.178 -3.273,3.404 0,2.27 1.637,3.426 3.23,3.426 1.178,0 2.355,-0.633 2.836,-1.92 h 2.27 c -0.545,2.662 -2.836,3.971 -5.148,3.971 -2.75,0 -5.543,-1.832 -5.543,-5.477 0,-3.623 2.793,-5.5 5.521,-5.521 2.291,-0.02 4.537,1.223 5.105,3.797 z"     id="path3992"     inkscape:connector-curvature="0"     style="fill:#6bbe6d" />    <path     d="m 453.791,164.723 h 3.645 v 1.703 h -3.645 v 4.734 c 0,2.684 1.682,2.857 3.842,2.094 l 0.238,1.791 c -3.6,1.111 -6.414,0.283 -6.414,-3.842 v -4.777 l -2.139,-0.152 v -1.551 h 2.139 l 0.24,-3.252 h 2.094 z"     id="path3994"     inkscape:connector-curvature="0"     style="fill:#6bbe6d" />    <path     d="m 464.725,175.414 c -2.773,0 -5.545,-1.832 -5.545,-5.498 0,-3.623 2.707,-5.434 5.455,-5.477 2.816,-0.045 5.652,1.789 5.652,5.477 0,3.666 -2.793,5.498 -5.562,5.498 z m 0.043,-2.094 c 1.57,-0.023 3.141,-1.156 3.141,-3.404 0,-2.291 -1.656,-3.426 -3.273,-3.383 -1.57,0.045 -3.098,1.156 -3.098,3.383 -0.001,2.291 1.612,3.426 3.23,3.404 z"     id="path3996"     inkscape:connector-curvature="0"     style="fill:#6bbe6d" />    <path     d="m 478.404,164.352 c 0.873,-0.023 1.746,0.238 2.422,0.744 l -0.59,2.047 c -0.633,-0.414 -1.33,-0.631 -2.096,-0.631 -1.418,0 -2.682,0.916 -2.682,2.619 v 6.088 h -2.357 v -7.637 c 0,-0.939 0,-1.418 -1.135,-1.354 l -0.021,-1.615 c 1.549,-0.35 3.25,-0.086 3.359,1.615 0.417,-1.222 1.813,-1.876 3.1,-1.876 z"     id="path3998"     inkscape:connector-curvature="0"     style="fill:#6bbe6d" />    <path     d="m 484.057,172.119 c 0.062,1.092 1.264,1.592 2.398,1.592 1.156,0 2.443,-0.324 2.51,-1.611 0,-0.961 -0.982,-1.244 -2.355,-1.418 -2.162,-0.285 -4.584,-0.525 -4.65,-2.904 0,-2.246 2.184,-3.295 4.473,-3.295 2.424,0 4.541,1.068 4.475,3.164 h -2.094 c 0,-1.047 -1.266,-1.373 -2.381,-1.373 -1.09,0 -2.225,0.521 -2.158,1.463 0.021,0.869 0.873,1.066 2.51,1.264 2.203,0.283 4.342,0.654 4.342,3.141 0,2.336 -2.248,3.34 -4.582,3.34 -2.336,0 -4.648,-0.742 -4.822,-3.361 h 2.334 z"     id="path4000"     inkscape:connector-curvature="0"     style="fill:#6bbe6d" />   </g>   <g     id="g4016">    <path     d="m 286.34,114.685 c -3.296,-4.02 -8.596,-6.145 -15.327,-6.145 -10.503,0 -21.22,6.436 -21.488,20.813 -0.195,6.361 1.782,11.877 5.721,15.938 4.102,4.229 10.114,6.559 16.932,6.559 0.19,0 0.386,-0.002 0.577,-0.006 4.883,0 10.324,-1.225 15.303,-3.447 0.418,-0.188 0.656,-0.633 0.578,-1.084 l -1.146,-6.637 c -0.053,-0.303 -0.241,-0.564 -0.512,-0.711 -0.147,-0.078 -0.311,-0.119 -0.474,-0.119 -0.137,0 -0.273,0.029 -0.401,0.084 -3.717,1.631 -7.643,2.424 -12.004,2.424 -0.615,0 -1.25,-0.018 -1.887,-0.049 -0.017,0 -0.033,-0.002 -0.05,-0.002 -6.714,0 -11.343,-3.764 -11.825,-9.473 h 28.134 c 0.477,0 0.888,-0.336 0.98,-0.803 1.424,-7.125 0.349,-13.121 -3.111,-17.342 z m -25.613,9.836 c 1.682,-5.829 6.41,-7.098 10.204,-7.098 3.073,0 5.788,0.991 7.447,2.722 1.132,1.179 1.759,2.648 1.87,4.376 z"     id="path4004"     inkscape:connector-curvature="0"     style="fill:#273029" />    <path     d="m 342.92,108.62 h -17.662 c -0.553,0 -1,0.448 -1,1 v 41.306 c 0,0.553 0.447,1 1,1 h 8.199 c 0.553,0 1,-0.447 1,-1 v -10.812 h 8.463 c 11.465,0 18.311,-5.834 18.311,-15.606 -10e-4,-9.949 -6.846,-15.888 -18.311,-15.888 z m 0,22.343 h -8.604 v -13.264 h 8.604 c 5.852,0 8.461,2.035 8.461,6.598 0,5.974 -4.83,6.666 -8.461,6.666 z"     id="path4006"     inkscape:connector-curvature="0"     style="fill:#273029" />    <g     id="g4014">     <path     d="m 385.471,108.54 c -10.502,0 -21.219,6.436 -21.488,20.813 -0.195,6.361 1.783,11.877 5.721,15.938 4.102,4.23 10.113,6.559 16.93,6.559 0.191,0 0.385,-0.002 0.578,-0.006 4.881,0 10.322,-1.225 15.305,-3.447 0.418,-0.188 0.656,-0.633 0.578,-1.084 l -1.148,-6.637 c -0.053,-0.303 -0.242,-0.564 -0.514,-0.711 -0.146,-0.078 -0.309,-0.119 -0.473,-0.119 -0.137,0 -0.273,0.029 -0.402,0.084 -3.715,1.631 -7.641,2.424 -12.002,2.424 -0.615,0 -1.25,-0.018 -1.887,-0.049 -6.762,-0.002 -11.395,-3.766 -11.877,-9.475 h 28.137 c 0.477,0 0.887,-0.336 0.98,-0.803 1.424,-7.125 0.348,-13.123 -3.113,-17.344 -3.296,-4.019 -8.595,-6.143 -15.325,-6.143 z m -10.287,15.981 c 1.684,-5.829 6.412,-7.098 10.205,-7.098 3.072,0 5.787,0.992 7.447,2.722 1.133,1.18 1.76,2.648 1.871,4.376 z"     id="path4008"     inkscape:connector-curvature="0"     style="fill:#273029" />     <path     d="m 450.055,144.193 c -0.184,-0.162 -0.418,-0.25 -0.66,-0.25 -0.031,0 -0.062,0.002 -0.096,0.006 -0.283,0.027 -0.549,0.041 -0.789,0.041 -0.801,0 -1.334,-0.146 -1.633,-0.443 -0.586,-0.588 -0.584,-2.105 -0.58,-3.863 v -0.396 -15.569 c 0,-9.841 -6.787,-15.26 -19.111,-15.26 -5.545,0 -11.027,1.175 -15.043,3.223 -0.402,0.204 -0.617,0.651 -0.525,1.092 l 1.312,6.393 c 0.062,0.305 0.262,0.562 0.541,0.698 0.139,0.067 0.289,0.101 0.438,0.101 0.154,0 0.307,-0.035 0.447,-0.105 2.055,-1.027 7.166,-2.475 12.098,-2.475 2.762,0.001 5.033,0.476 6.57,1.374 1.74,1.016 2.586,2.558 2.586,4.714 v 2.306 c -3.23,-1.487 -7.047,-2.323 -10.719,-2.323 -5.277,0 -9.768,1.626 -12.643,4.577 -2.52,2.586 -3.793,6.176 -3.684,10.383 0,3.852 1.691,7.338 4.762,9.789 2.766,2.211 6.562,3.477 10.416,3.477 4.701,0 10.43,-1.506 13.836,-5.553 0.832,3.666 3.201,5.395 7.301,5.395 1.645,0 3.455,-0.273 4.85,-0.512 0.492,-0.084 0.846,-0.52 0.83,-1.018 l -0.164,-5.08 c -0.01,-0.28 -0.133,-0.54 -0.34,-0.722 z m -14.446,-7.865 c -0.842,4.33 -5.793,6.303 -10.064,6.303 -3.092,0 -6.211,-1.465 -6.211,-4.736 0,-4.668 3.799,-6.395 7.051,-6.457 0.123,-0.002 0.242,-0.004 0.363,-0.004 2.961,0 6.158,0.832 8.861,2.293 z"     id="path4010"     inkscape:connector-curvature="0"     style="fill:#273029" />     <path     d="m 473.945,125.594 c -6.742,-0.809 -8.498,-1.586 -8.553,-3.785 -0.061,-0.887 0.223,-1.65 0.842,-2.313 1.221,-1.309 3.682,-2.154 6.271,-2.154 1.324,0 7.934,0.2 7.934,4.164 0,0.552 0.447,1 1,1 h 7.867 c 0.541,0 0.982,-0.429 1,-0.969 0.094,-3.015 -0.945,-5.733 -3.008,-7.86 -3.113,-3.213 -8.506,-5.056 -14.793,-5.056 -8.859,0 -17.801,4.136 -17.801,13.377 0.264,9.54 9.463,10.737 17.582,11.792 l 0.746,0.098 c 5.797,0.736 7.963,1.906 7.979,4.311 -0.232,4.207 -4.707,5.09 -8.424,5.09 -3.715,0 -7.809,-1.578 -8.018,-5.041 -0.031,-0.529 -0.469,-0.941 -0.998,-0.941 h -8.77 c -0.277,0 -0.541,0.115 -0.73,0.318 -0.189,0.201 -0.285,0.473 -0.268,0.748 0.584,8.742 7.371,13.555 19.111,13.555 4.834,0 9.248,-1.113 12.43,-3.137 3.781,-2.404 5.779,-6 5.779,-10.402 0.002,-10.582 -9.523,-11.81 -17.178,-12.795 z"     id="path4012"     inkscape:connector-curvature="0"     style="fill:#273029" />    </g>   </g>   <path     d="m 310.533,130.963 h -7.149 c -2.522,0 -4.574,2.053 -4.574,4.574 0,2.523 2.052,4.576 4.574,4.576 h 7.149 c 2.523,0 4.576,-2.053 4.576,-4.576 0,-2.521 -2.052,-4.574 -4.576,-4.574 z"     id="path4018"     inkscape:connector-curvature="0"     style="fill:#273029" />  </g>  </svg>
  </td>
  <td id="projectalign">
   <div id="projectname">AEM13920 Portal
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div id="loading">
  <div id="spinner">
    <div class="spin"></div>
  </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group___h_a_l___a_e_m13920___a_p_i.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">HAL Driver API</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p >AEM13920's HAL Driver's API. </p>
<p ><br  />
 This document describes the AEM13920 HAL Driver's API. It provides information about all the functions and data structures that can be used to interface the AEM.</p>
<p >Please refer to the <a class="el" href="index.html">Getting Started</a> page for further guidance on how to use this driver</p>
<dl class="section version"><dt>Version</dt><dd>1.0.0<ul>
<li>First public release </li>
</ul>
</dd>
<dd>
1.0.1<ul>
<li>Minor bug fixes </li>
</ul>
</dd>
<dd>
1.1.0 API Improvement<ul>
<li>Precise in and out parameters in the API documentation Deprecation</li>
<li>Deprecate GetAPMSource and GetAPMBuck, replaced by GetAPMDataSRC and GetAPMDataBuck </li>
</ul>
</dd>
<dd>
1.1.1 Bug Fix<ul>
<li>Remove useless condition </li>
</ul>
</dd>
<dd>
2.0.0 Breaking Change<ul>
<li>Complete API revision </li>
</ul>
</dd>
<dd>
2.0.1 Bug Fix<ul>
<li>Small fix in IsAPMSourceOverflow and IsAPMSourceCorrupted functions</li>
<li>Small fix in GetAPMXXXData functions</li>
<li>Bug fix in GetTempXXXStatus </li>
</ul>
</dd>
<dd>
2.0.2 Bug Fix<ul>
<li>Make GetConfiguration also return the regulation mode</li>
<li>Fix error in SetConfiguration for sources' config</li>
<li>Remove useless include </li>
</ul>
</dd></dl>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:struct_a_e_m13920___handler__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a></td></tr>
<tr class="memdesc:struct_a_e_m13920___handler__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">AEM13920 handler.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">More...</a><br /></td></tr>
<tr class="separator:struct_a_e_m13920___handler__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_a_e_m13920___c_o_n_f_i_g__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___c_o_n_f_i_g__t">AEM13920_CONFIG_t</a></td></tr>
<tr class="memdesc:struct_a_e_m13920___c_o_n_f_i_g__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">AEM13920's configuration settings.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___c_o_n_f_i_g__t">More...</a><br /></td></tr>
<tr class="separator:struct_a_e_m13920___c_o_n_f_i_g__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9eb083a7b35a8682dde64fa11a14055f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga9eb083a7b35a8682dde64fa11a14055f">AEM13920_Initialize</a> (<a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler)</td></tr>
<tr class="memdesc:ga9eb083a7b35a8682dde64fa11a14055f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the driver.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga9eb083a7b35a8682dde64fa11a14055f">More...</a><br /></td></tr>
<tr class="separator:ga9eb083a7b35a8682dde64fa11a14055f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacf528a2600a42d317f0a898064cea50"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaacf528a2600a42d317f0a898064cea50">AEM13920_Deinitialize</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler)</td></tr>
<tr class="memdesc:gaacf528a2600a42d317f0a898064cea50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deinitialize the driver.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gaacf528a2600a42d317f0a898064cea50">More...</a><br /></td></tr>
<tr class="separator:gaacf528a2600a42d317f0a898064cea50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6b7fcbcc3aad9e0003b85ede536db92"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gab6b7fcbcc3aad9e0003b85ede536db92">AEM13920_GetSourceRegulationMode</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> src, <a class="el" href="group___a_e_m13920___common.html#gacb18d945a027bcda7a2f30ea0103f2b5">AEM13920_SRCREGU_MODE</a> *mode)</td></tr>
<tr class="memdesc:gab6b7fcbcc3aad9e0003b85ede536db92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the SRCx regulation mode.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gab6b7fcbcc3aad9e0003b85ede536db92">More...</a><br /></td></tr>
<tr class="separator:gab6b7fcbcc3aad9e0003b85ede536db92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2118409faadb17ffe64726f644e208db"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga2118409faadb17ffe64726f644e208db">AEM13920_SetSourceRegulationMode</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> src, <a class="el" href="group___a_e_m13920___common.html#gacb18d945a027bcda7a2f30ea0103f2b5">AEM13920_SRCREGU_MODE</a> mode)</td></tr>
<tr class="memdesc:ga2118409faadb17ffe64726f644e208db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set SRCx' regulation mode.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga2118409faadb17ffe64726f644e208db">More...</a><br /></td></tr>
<tr class="separator:ga2118409faadb17ffe64726f644e208db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade23493c7e53c0222555e3eaf405049c"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gade23493c7e53c0222555e3eaf405049c">AEM13920_GetSourceRegulationVoltage</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> src, uint32_t *srcregu)</td></tr>
<tr class="memdesc:gade23493c7e53c0222555e3eaf405049c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the voltage at which the SRCx is regulated.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gade23493c7e53c0222555e3eaf405049c">More...</a><br /></td></tr>
<tr class="separator:gade23493c7e53c0222555e3eaf405049c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35f829385956d74821d427b27c50843d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga35f829385956d74821d427b27c50843d">AEM13920_SetSourceConstantVoltage</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> src, uint32_t srcregu)</td></tr>
<tr class="memdesc:ga35f829385956d74821d427b27c50843d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set SRCx's regulation to a constant voltage.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga35f829385956d74821d427b27c50843d">More...</a><br /></td></tr>
<tr class="separator:ga35f829385956d74821d427b27c50843d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga854fbe1ed90df7646dff8d16c0c4348f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga854fbe1ed90df7646dff8d16c0c4348f">AEM13920_GetMPPTConfig</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> src, <a class="el" href="group___a_e_m13920___common.html#struct_a_e_m13920___m_p_p_t_c_f_g__t">AEM13920_MPPTCFG_t</a> *cfg)</td></tr>
<tr class="memdesc:ga854fbe1ed90df7646dff8d16c0c4348f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the MPPT configuration for SRCx (ratio, period, and duration)  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga854fbe1ed90df7646dff8d16c0c4348f">More...</a><br /></td></tr>
<tr class="separator:ga854fbe1ed90df7646dff8d16c0c4348f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15fde65c5cf6d997fdfefdd3d7c4ac90"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga15fde65c5cf6d997fdfefdd3d7c4ac90">AEM13920_SetMPPTConfig</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> src, const <a class="el" href="group___a_e_m13920___common.html#struct_a_e_m13920___m_p_p_t_c_f_g__t">AEM13920_MPPTCFG_t</a> *cfg)</td></tr>
<tr class="memdesc:ga15fde65c5cf6d997fdfefdd3d7c4ac90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the MPPT configuration for SRCx (ratio, period, and duration)  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga15fde65c5cf6d997fdfefdd3d7c4ac90">More...</a><br /></td></tr>
<tr class="separator:ga15fde65c5cf6d997fdfefdd3d7c4ac90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga750a459aa627a44c0ed10ea176270320"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga750a459aa627a44c0ed10ea176270320">AEM13920_GetMPPTRatio</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> src, <a class="el" href="group___a_e_m13920___common.html#ga7d6badc834d624377918cb765257eb21">AEM13920_MPPT_RATIO</a> *ratio)</td></tr>
<tr class="memdesc:ga750a459aa627a44c0ed10ea176270320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the configured MPPT ratio for SRCx.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga750a459aa627a44c0ed10ea176270320">More...</a><br /></td></tr>
<tr class="separator:ga750a459aa627a44c0ed10ea176270320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0c5027a9cfc427091613914607accd1"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gab0c5027a9cfc427091613914607accd1">AEM13920_SetMPPTRatio</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> src, <a class="el" href="group___a_e_m13920___common.html#ga7d6badc834d624377918cb765257eb21">AEM13920_MPPT_RATIO</a> ratio)</td></tr>
<tr class="memdesc:gab0c5027a9cfc427091613914607accd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the MPPT ratio for SRCx.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gab0c5027a9cfc427091613914607accd1">More...</a><br /></td></tr>
<tr class="separator:gab0c5027a9cfc427091613914607accd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8522aa225c7ec9101653ad81e17d5797"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga8522aa225c7ec9101653ad81e17d5797">AEM13920_GetMPPTDuration</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> src, <a class="el" href="group___a_e_m13920___common.html#gaa2752ec46c5474b8438482c31f542bd9">AEM13920_MPPT_DURATION</a> *duration)</td></tr>
<tr class="memdesc:ga8522aa225c7ec9101653ad81e17d5797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the configured MPPT duration for SRCx.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga8522aa225c7ec9101653ad81e17d5797">More...</a><br /></td></tr>
<tr class="separator:ga8522aa225c7ec9101653ad81e17d5797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21adc4e2b75e726fde224af614c62d8d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga21adc4e2b75e726fde224af614c62d8d">AEM13920_SetMPPTDuration</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> src, <a class="el" href="group___a_e_m13920___common.html#gaa2752ec46c5474b8438482c31f542bd9">AEM13920_MPPT_DURATION</a> duration)</td></tr>
<tr class="memdesc:ga21adc4e2b75e726fde224af614c62d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the MPPT duration for SRCx.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga21adc4e2b75e726fde224af614c62d8d">More...</a><br /></td></tr>
<tr class="separator:ga21adc4e2b75e726fde224af614c62d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72a64dc0b3953c53d9c82cc43af69469"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga72a64dc0b3953c53d9c82cc43af69469">AEM13920_GetMPPTPeriod</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> src, <a class="el" href="group___a_e_m13920___common.html#ga74be84c7513ff30f51bedfe7c254c0be">AEM13920_MPPT_PERIOD</a> *period)</td></tr>
<tr class="memdesc:ga72a64dc0b3953c53d9c82cc43af69469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the configured MPPT period for SRCx.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga72a64dc0b3953c53d9c82cc43af69469">More...</a><br /></td></tr>
<tr class="separator:ga72a64dc0b3953c53d9c82cc43af69469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3585b2b342431573cd0b2c04342696d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gac3585b2b342431573cd0b2c04342696d">AEM13920_SetMPPTPeriod</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> src, <a class="el" href="group___a_e_m13920___common.html#ga74be84c7513ff30f51bedfe7c254c0be">AEM13920_MPPT_PERIOD</a> period)</td></tr>
<tr class="memdesc:gac3585b2b342431573cd0b2c04342696d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the MPPT period for SRCx.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gac3585b2b342431573cd0b2c04342696d">More...</a><br /></td></tr>
<tr class="separator:gac3585b2b342431573cd0b2c04342696d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a7e3cf39bd40165686f06cc2baeab0c"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga9a7e3cf39bd40165686f06cc2baeab0c">AEM13920_GetOverdischargeVoltage</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, uint32_t *vovdis)</td></tr>
<tr class="memdesc:ga9a7e3cf39bd40165686f06cc2baeab0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the configured VOVDIS threshold (mV)  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga9a7e3cf39bd40165686f06cc2baeab0c">More...</a><br /></td></tr>
<tr class="separator:ga9a7e3cf39bd40165686f06cc2baeab0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga977e09029a4df85e82f3667d8cb4285f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga977e09029a4df85e82f3667d8cb4285f">AEM13920_SetOverdischargeVoltage</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, uint32_t vovdis)</td></tr>
<tr class="memdesc:ga977e09029a4df85e82f3667d8cb4285f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the VOVDIS threshold (mV)  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga977e09029a4df85e82f3667d8cb4285f">More...</a><br /></td></tr>
<tr class="separator:ga977e09029a4df85e82f3667d8cb4285f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57b290f75eddd13dff9482ae21065313"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga57b290f75eddd13dff9482ae21065313">AEM13920_GetChargeReadyVoltage</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, uint32_t *vchrdy)</td></tr>
<tr class="memdesc:ga57b290f75eddd13dff9482ae21065313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the configured VCHRDY threshold (mV)  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga57b290f75eddd13dff9482ae21065313">More...</a><br /></td></tr>
<tr class="separator:ga57b290f75eddd13dff9482ae21065313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16f4672905b61b364903b655b93d0eb1"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga16f4672905b61b364903b655b93d0eb1">AEM13920_SetChargeReadyVoltage</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, uint32_t vchrdy)</td></tr>
<tr class="memdesc:ga16f4672905b61b364903b655b93d0eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the VCHRDY threshold (mV)  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga16f4672905b61b364903b655b93d0eb1">More...</a><br /></td></tr>
<tr class="separator:ga16f4672905b61b364903b655b93d0eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7089449a795c3e7ebbf9242e364fbc8"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf7089449a795c3e7ebbf9242e364fbc8">AEM13920_GetOverchargeVoltage</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, uint32_t *vovch)</td></tr>
<tr class="memdesc:gaf7089449a795c3e7ebbf9242e364fbc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the configured VOVCH threshold (mV)  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gaf7089449a795c3e7ebbf9242e364fbc8">More...</a><br /></td></tr>
<tr class="separator:gaf7089449a795c3e7ebbf9242e364fbc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa0c702028228b0f80bd5d834970ee68"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gafa0c702028228b0f80bd5d834970ee68">AEM13920_SetOverchargeVoltage</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, uint32_t vovch)</td></tr>
<tr class="memdesc:gafa0c702028228b0f80bd5d834970ee68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the VOVCH threshold (mV)  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gafa0c702028228b0f80bd5d834970ee68">More...</a><br /></td></tr>
<tr class="separator:gafa0c702028228b0f80bd5d834970ee68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21012b694a6aec710e3f7a468444cc52"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga21012b694a6aec710e3f7a468444cc52">AEM13920_GetBoostConfig</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> src, <a class="el" href="group___a_e_m13920___common.html#struct_a_e_m13920___b_s_t_c_f_g__t">AEM13920_BSTCFG_t</a> *cfg)</td></tr>
<tr class="memdesc:ga21012b694a6aec710e3f7a468444cc52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the boost configuration for SRCx.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga21012b694a6aec710e3f7a468444cc52">More...</a><br /></td></tr>
<tr class="separator:ga21012b694a6aec710e3f7a468444cc52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bd4acfc22ee294d3199c784831443a5"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga8bd4acfc22ee294d3199c784831443a5">AEM13920_SetBoostConfig</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> src, const <a class="el" href="group___a_e_m13920___common.html#struct_a_e_m13920___b_s_t_c_f_g__t">AEM13920_BSTCFG_t</a> *cfg)</td></tr>
<tr class="memdesc:ga8bd4acfc22ee294d3199c784831443a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the boost configuration for SRCx.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga8bd4acfc22ee294d3199c784831443a5">More...</a><br /></td></tr>
<tr class="separator:ga8bd4acfc22ee294d3199c784831443a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab598380ff2f0268dae11a068f8b22394"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gab598380ff2f0268dae11a068f8b22394">AEM13920_EnableBoost</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> src)</td></tr>
<tr class="memdesc:gab598380ff2f0268dae11a068f8b22394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the boost converter for SRCx.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gab598380ff2f0268dae11a068f8b22394">More...</a><br /></td></tr>
<tr class="separator:gab598380ff2f0268dae11a068f8b22394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab683fa2d584c043f435f826165281626"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gab683fa2d584c043f435f826165281626">AEM13920_DisableBoost</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> src)</td></tr>
<tr class="memdesc:gab683fa2d584c043f435f826165281626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the boost converter for SRCx.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gab683fa2d584c043f435f826165281626">More...</a><br /></td></tr>
<tr class="separator:gab683fa2d584c043f435f826165281626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga970fa2bb5bfb54eb0690084ed9c3c201"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga970fa2bb5bfb54eb0690084ed9c3c201">AEM13920_IsEnabledBoost</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> src, bool *en)</td></tr>
<tr class="memdesc:ga970fa2bb5bfb54eb0690084ed9c3c201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the enabling status of the boost converter for SRCx.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga970fa2bb5bfb54eb0690084ed9c3c201">More...</a><br /></td></tr>
<tr class="separator:ga970fa2bb5bfb54eb0690084ed9c3c201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ea7942ee4ff16cb4f5cc433eed1a150"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga5ea7942ee4ff16cb4f5cc433eed1a150">AEM13920_EnableHighPower</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> src)</td></tr>
<tr class="memdesc:ga5ea7942ee4ff16cb4f5cc433eed1a150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the high power mode for SRCx.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga5ea7942ee4ff16cb4f5cc433eed1a150">More...</a><br /></td></tr>
<tr class="separator:ga5ea7942ee4ff16cb4f5cc433eed1a150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab531d584f77f693de01d1cb95620edea"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gab531d584f77f693de01d1cb95620edea">AEM13920_DisableHighPower</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> src)</td></tr>
<tr class="memdesc:gab531d584f77f693de01d1cb95620edea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Diable the high power mode for SRCx.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gab531d584f77f693de01d1cb95620edea">More...</a><br /></td></tr>
<tr class="separator:gab531d584f77f693de01d1cb95620edea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33628925f8b797baf5e856c24483b502"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga33628925f8b797baf5e856c24483b502">AEM13920_IsEnabledHighPower</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> src, bool *en)</td></tr>
<tr class="memdesc:ga33628925f8b797baf5e856c24483b502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the enabling status of the high power mode for SRCx.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga33628925f8b797baf5e856c24483b502">More...</a><br /></td></tr>
<tr class="separator:ga33628925f8b797baf5e856c24483b502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb4f46e9f099e435be92337a24b150b3"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gacb4f46e9f099e435be92337a24b150b3">AEM13920_SetBoostTimingMultiplier</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> src, <a class="el" href="group___a_e_m13920___common.html#gaf5a0206be099bb00343f8142ed830d8c">AEM13920_TMULT</a> tmult)</td></tr>
<tr class="memdesc:gacb4f46e9f099e435be92337a24b150b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the boost converter's timing multiplier for SRCx.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gacb4f46e9f099e435be92337a24b150b3">More...</a><br /></td></tr>
<tr class="separator:gacb4f46e9f099e435be92337a24b150b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14a338660e28bf9df0c952f837064bac"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga14a338660e28bf9df0c952f837064bac">AEM13920_GetBoostTimingMultiplier</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> src, <a class="el" href="group___a_e_m13920___common.html#gaf5a0206be099bb00343f8142ed830d8c">AEM13920_TMULT</a> *tmult)</td></tr>
<tr class="memdesc:ga14a338660e28bf9df0c952f837064bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the configured boost converter's timing multiplier for SRCx.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga14a338660e28bf9df0c952f837064bac">More...</a><br /></td></tr>
<tr class="separator:ga14a338660e28bf9df0c952f837064bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70d97b1bdadc7dfae2d08c40a5924665"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga70d97b1bdadc7dfae2d08c40a5924665">AEM13920_SetBuckConfig</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, const <a class="el" href="group___a_e_m13920___common.html#struct_a_e_m13920___b_u_c_k_c_f_g__t">AEM13920_BUCKCFG_t</a> *cfg)</td></tr>
<tr class="memdesc:ga70d97b1bdadc7dfae2d08c40a5924665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the buck converter's configuration.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga70d97b1bdadc7dfae2d08c40a5924665">More...</a><br /></td></tr>
<tr class="separator:ga70d97b1bdadc7dfae2d08c40a5924665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc9b2d744e77f8d8cfa3d0e7f27d7c4c"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gafc9b2d744e77f8d8cfa3d0e7f27d7c4c">AEM13920_GetBuckConfig</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#struct_a_e_m13920___b_u_c_k_c_f_g__t">AEM13920_BUCKCFG_t</a> *cfg)</td></tr>
<tr class="memdesc:gafc9b2d744e77f8d8cfa3d0e7f27d7c4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the buck converter's configuration.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gafc9b2d744e77f8d8cfa3d0e7f27d7c4c">More...</a><br /></td></tr>
<tr class="separator:gafc9b2d744e77f8d8cfa3d0e7f27d7c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5ba4480084340f1b25416b55db8a863"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gab5ba4480084340f1b25416b55db8a863">AEM13920_SetBuckVOUT</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#gabd96065f60e993d0a866343dfcacb1fb">AEM13920_VOUT</a> vout)</td></tr>
<tr class="memdesc:gab5ba4480084340f1b25416b55db8a863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the buck converter's output regulation voltage.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gab5ba4480084340f1b25416b55db8a863">More...</a><br /></td></tr>
<tr class="separator:gab5ba4480084340f1b25416b55db8a863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00cba59af52811b1b802fd3007f90716"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga00cba59af52811b1b802fd3007f90716">AEM13920_GetBuckVOUT</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#gabd96065f60e993d0a866343dfcacb1fb">AEM13920_VOUT</a> *vout)</td></tr>
<tr class="memdesc:ga00cba59af52811b1b802fd3007f90716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the buck converter's output regulation voltage.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga00cba59af52811b1b802fd3007f90716">More...</a><br /></td></tr>
<tr class="separator:ga00cba59af52811b1b802fd3007f90716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11e0b18de78293de56f7a65ccbdf1c68"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga11e0b18de78293de56f7a65ccbdf1c68">AEM13920_SetBuckTimingMultiplier</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#gaf5a0206be099bb00343f8142ed830d8c">AEM13920_TMULT</a> tmult)</td></tr>
<tr class="memdesc:ga11e0b18de78293de56f7a65ccbdf1c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the buck converter's timing multiplier.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga11e0b18de78293de56f7a65ccbdf1c68">More...</a><br /></td></tr>
<tr class="separator:ga11e0b18de78293de56f7a65ccbdf1c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f5b017dd4ca89ab52a2138fc56de87f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga4f5b017dd4ca89ab52a2138fc56de87f">AEM13920_GetBuckTimingMultiplier</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#gaf5a0206be099bb00343f8142ed830d8c">AEM13920_TMULT</a> *tmult)</td></tr>
<tr class="memdesc:ga4f5b017dd4ca89ab52a2138fc56de87f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the buck converter's configured timing multiplier.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga4f5b017dd4ca89ab52a2138fc56de87f">More...</a><br /></td></tr>
<tr class="separator:ga4f5b017dd4ca89ab52a2138fc56de87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03f3fc61d5874ab46f802701663010a2"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga03f3fc61d5874ab46f802701663010a2">AEM13920_GetTempColdChargeThresh</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, uint32_t *rth, uint32_t rdiv)</td></tr>
<tr class="memdesc:ga03f3fc61d5874ab46f802701663010a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the configured thermistor impedance (RTH) at the minimum accepted temperature for charging the storage element.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga03f3fc61d5874ab46f802701663010a2">More...</a><br /></td></tr>
<tr class="separator:ga03f3fc61d5874ab46f802701663010a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27d9f7a8c644d0a90ce1f5ee00c144ab"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga27d9f7a8c644d0a90ce1f5ee00c144ab">AEM13920_SetTempColdChargeThresh</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, uint32_t rth, uint32_t rdiv)</td></tr>
<tr class="memdesc:ga27d9f7a8c644d0a90ce1f5ee00c144ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the thermistor impedance (RTH) at the minimum accepted temperature for charging the storage element.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga27d9f7a8c644d0a90ce1f5ee00c144ab">More...</a><br /></td></tr>
<tr class="separator:ga27d9f7a8c644d0a90ce1f5ee00c144ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5147ef4bca0b7f20ebf3e86deaf127c9"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga5147ef4bca0b7f20ebf3e86deaf127c9">AEM13920_GetTempHotChargeThresh</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, uint32_t *rth, uint32_t rdiv)</td></tr>
<tr class="memdesc:ga5147ef4bca0b7f20ebf3e86deaf127c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the configured thermistor impedance at the maximum temperature for storage element charging.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga5147ef4bca0b7f20ebf3e86deaf127c9">More...</a><br /></td></tr>
<tr class="separator:ga5147ef4bca0b7f20ebf3e86deaf127c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dfc40610c7c28912c72b4933eaf2cf4"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga5dfc40610c7c28912c72b4933eaf2cf4">AEM13920_SetTempHotChargeThresh</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, uint32_t rth, uint32_t rdiv)</td></tr>
<tr class="memdesc:ga5dfc40610c7c28912c72b4933eaf2cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the thermistor impedance at the maximum temperature for storage element charging.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga5dfc40610c7c28912c72b4933eaf2cf4">More...</a><br /></td></tr>
<tr class="separator:ga5dfc40610c7c28912c72b4933eaf2cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f5103e0a598e46bae7fc585dd5b19b4"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga5f5103e0a598e46bae7fc585dd5b19b4">AEM13920_GetTempColdDischargeThresh</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, uint32_t *rth, uint32_t rdiv)</td></tr>
<tr class="memdesc:ga5f5103e0a598e46bae7fc585dd5b19b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the configured thermistor impedance at the minimum temperature for storage element discharging.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga5f5103e0a598e46bae7fc585dd5b19b4">More...</a><br /></td></tr>
<tr class="separator:ga5f5103e0a598e46bae7fc585dd5b19b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a9bef8360211bfb3d61ec9a9dfcd714"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga1a9bef8360211bfb3d61ec9a9dfcd714">AEM13920_SetTempColdDischargeThresh</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, uint32_t rth, uint32_t rdiv)</td></tr>
<tr class="memdesc:ga1a9bef8360211bfb3d61ec9a9dfcd714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the thermistor impedance at the minimum temperature for storage element discharging.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga1a9bef8360211bfb3d61ec9a9dfcd714">More...</a><br /></td></tr>
<tr class="separator:ga1a9bef8360211bfb3d61ec9a9dfcd714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19baa44b9e7dacacd13416ddcc8055e6"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga19baa44b9e7dacacd13416ddcc8055e6">AEM13920_GetTempHotDischargeThresh</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, uint32_t *rth, uint32_t rdiv)</td></tr>
<tr class="memdesc:ga19baa44b9e7dacacd13416ddcc8055e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the configured thermistor impedance at the maximum temperature for storage element discharging.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga19baa44b9e7dacacd13416ddcc8055e6">More...</a><br /></td></tr>
<tr class="separator:ga19baa44b9e7dacacd13416ddcc8055e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e7dd874220c8465591d277ec30c4ada"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga3e7dd874220c8465591d277ec30c4ada">AEM13920_SetTempHotDischargeThresh</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, uint32_t rth, uint32_t rdiv)</td></tr>
<tr class="memdesc:ga3e7dd874220c8465591d277ec30c4ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the thermistor impedance at the maximum temperature for storage element discharging.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga3e7dd874220c8465591d277ec30c4ada">More...</a><br /></td></tr>
<tr class="separator:ga3e7dd874220c8465591d277ec30c4ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41df19aaf0d3ffad0f964b98b93f465c"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga41df19aaf0d3ffad0f964b98b93f465c">AEM13920_EnableTempMon</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler)</td></tr>
<tr class="memdesc:ga41df19aaf0d3ffad0f964b98b93f465c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the monitoring of the ambient temperature.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga41df19aaf0d3ffad0f964b98b93f465c">More...</a><br /></td></tr>
<tr class="separator:ga41df19aaf0d3ffad0f964b98b93f465c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34f1dde7c33bfbe8abb355959f76edde"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga34f1dde7c33bfbe8abb355959f76edde">AEM13920_DisableTempMon</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler)</td></tr>
<tr class="memdesc:ga34f1dde7c33bfbe8abb355959f76edde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the monitoring of the ambient temperature.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga34f1dde7c33bfbe8abb355959f76edde">More...</a><br /></td></tr>
<tr class="separator:ga34f1dde7c33bfbe8abb355959f76edde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga339540468510d05e8c4067666fb2d6ea"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga339540468510d05e8c4067666fb2d6ea">AEM13920_IsEnabledTempMon</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, bool *en)</td></tr>
<tr class="memdesc:ga339540468510d05e8c4067666fb2d6ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the enabling status of the Temperature Monitoring.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga339540468510d05e8c4067666fb2d6ea">More...</a><br /></td></tr>
<tr class="separator:ga339540468510d05e8c4067666fb2d6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5d589f1e37205ac61b21cd279c99abe"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gac5d589f1e37205ac61b21cd279c99abe">AEM13920_SetSRCLOWConfig</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, const <a class="el" href="group___a_e_m13920___common.html#struct_a_e_m13920___s_r_c_l_o_w_c_f_g__t">AEM13920_SRCLOWCFG_t</a> *cfg)</td></tr>
<tr class="memdesc:gac5d589f1e37205ac61b21cd279c99abe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure both of the SRCLOW thresholds (SRC1 and SRC2)  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gac5d589f1e37205ac61b21cd279c99abe">More...</a><br /></td></tr>
<tr class="separator:gac5d589f1e37205ac61b21cd279c99abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d11a959996e60a231455de8c2665bc4"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga0d11a959996e60a231455de8c2665bc4">AEM13920_GetSRCLOWConfig</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#struct_a_e_m13920___s_r_c_l_o_w_c_f_g__t">AEM13920_SRCLOWCFG_t</a> *cfg)</td></tr>
<tr class="memdesc:ga0d11a959996e60a231455de8c2665bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get both of the SRCLOW thresholds (SRC1 and SRC2)  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga0d11a959996e60a231455de8c2665bc4">More...</a><br /></td></tr>
<tr class="separator:ga0d11a959996e60a231455de8c2665bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5a1a027787bb9b45c96abf287c52097"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gab5a1a027787bb9b45c96abf287c52097">AEM13920_SetSRCLowThresh</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> src, <a class="el" href="group___a_e_m13920___common.html#ga77893383a955ca777943627c7fe48f4a">AEM13920_SRCLOW_THRESH</a> thresh)</td></tr>
<tr class="memdesc:gab5a1a027787bb9b45c96abf287c52097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set SRCx' low threshold.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gab5a1a027787bb9b45c96abf287c52097">More...</a><br /></td></tr>
<tr class="separator:gab5a1a027787bb9b45c96abf287c52097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0d59b4bf19eb9a784299a90567003f6"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf0d59b4bf19eb9a784299a90567003f6">AEM13920_GetSRCLowThresh</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> src, <a class="el" href="group___a_e_m13920___common.html#ga77893383a955ca777943627c7fe48f4a">AEM13920_SRCLOW_THRESH</a> *thresh)</td></tr>
<tr class="memdesc:gaf0d59b4bf19eb9a784299a90567003f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the configured low threshold for SRCx.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gaf0d59b4bf19eb9a784299a90567003f6">More...</a><br /></td></tr>
<tr class="separator:gaf0d59b4bf19eb9a784299a90567003f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2796ae865a8200a976d51c2811c6226c"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga2796ae865a8200a976d51c2811c6226c">AEM13920_SetAPMConfig</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, const <a class="el" href="group___a_e_m13920___common.html#struct_a_e_m13920___a_p_m_c_f_g__t">AEM13920_APMCFG_t</a> *cfg)</td></tr>
<tr class="memdesc:ga2796ae865a8200a976d51c2811c6226c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the APM configuration.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga2796ae865a8200a976d51c2811c6226c">More...</a><br /></td></tr>
<tr class="separator:ga2796ae865a8200a976d51c2811c6226c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae52253bcb167e27e12b06d5239ad23b3"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gae52253bcb167e27e12b06d5239ad23b3">AEM13920_GetAPMConfig</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#struct_a_e_m13920___a_p_m_c_f_g__t">AEM13920_APMCFG_t</a> *cfg)</td></tr>
<tr class="memdesc:gae52253bcb167e27e12b06d5239ad23b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the APM configuration.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gae52253bcb167e27e12b06d5239ad23b3">More...</a><br /></td></tr>
<tr class="separator:gae52253bcb167e27e12b06d5239ad23b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9568bdb4876bfe0197b215af57023ae"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaa9568bdb4876bfe0197b215af57023ae">AEM13920_EnableAPMSource</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> src)</td></tr>
<tr class="memdesc:gaa9568bdb4876bfe0197b215af57023ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the Average Power Monitoring for the selected source.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gaa9568bdb4876bfe0197b215af57023ae">More...</a><br /></td></tr>
<tr class="separator:gaa9568bdb4876bfe0197b215af57023ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac21c6b501829f9249103d0f2b1d62b50"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gac21c6b501829f9249103d0f2b1d62b50">AEM13920_DisableAPMSource</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> src)</td></tr>
<tr class="memdesc:gac21c6b501829f9249103d0f2b1d62b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the Average Power Monitoring for the selected source.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gac21c6b501829f9249103d0f2b1d62b50">More...</a><br /></td></tr>
<tr class="separator:gac21c6b501829f9249103d0f2b1d62b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bfb53f3f2d90964f10fd9ceb2260070"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga6bfb53f3f2d90964f10fd9ceb2260070">AEM13920_IsEnabledAPMSource</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> src, bool *en)</td></tr>
<tr class="memdesc:ga6bfb53f3f2d90964f10fd9ceb2260070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the enabling status of the Average Power Monitoring for the selected source.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga6bfb53f3f2d90964f10fd9ceb2260070">More...</a><br /></td></tr>
<tr class="separator:ga6bfb53f3f2d90964f10fd9ceb2260070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab937a6dec346efc1668d12d3aec36fa8"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gab937a6dec346efc1668d12d3aec36fa8">AEM13920_EnableAPMBuck</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler)</td></tr>
<tr class="memdesc:gab937a6dec346efc1668d12d3aec36fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the Average Power Monitoring for the buck converter.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gab937a6dec346efc1668d12d3aec36fa8">More...</a><br /></td></tr>
<tr class="separator:gab937a6dec346efc1668d12d3aec36fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd193765764685a073e05380dfc43586"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gacd193765764685a073e05380dfc43586">AEM13920_DisableAPMBuck</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler)</td></tr>
<tr class="memdesc:gacd193765764685a073e05380dfc43586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the Average Power Monitoring for the buck converter.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gacd193765764685a073e05380dfc43586">More...</a><br /></td></tr>
<tr class="separator:gacd193765764685a073e05380dfc43586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a87eda4ed1c00b1b0a2b6957cedbd24"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga0a87eda4ed1c00b1b0a2b6957cedbd24">AEM13920_IsEnabledAPMBuck</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, bool *en)</td></tr>
<tr class="memdesc:ga0a87eda4ed1c00b1b0a2b6957cedbd24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the enabling status of the Average Power Monitoring for the buck converter.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga0a87eda4ed1c00b1b0a2b6957cedbd24">More...</a><br /></td></tr>
<tr class="separator:ga0a87eda4ed1c00b1b0a2b6957cedbd24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ecc1a13b7ae18d526fcf98e4106a4a0"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga1ecc1a13b7ae18d526fcf98e4106a4a0">AEM13920_SetAPMMode</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga14afbba9f4eb5541a246f6993103c0be">AEM13920_APM_MODE</a> mode)</td></tr>
<tr class="memdesc:ga1ecc1a13b7ae18d526fcf98e4106a4a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the APM functioning mode.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga1ecc1a13b7ae18d526fcf98e4106a4a0">More...</a><br /></td></tr>
<tr class="separator:ga1ecc1a13b7ae18d526fcf98e4106a4a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4be229f12a95385f3eeb7ae41a736dd9"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga4be229f12a95385f3eeb7ae41a736dd9">AEM13920_GetAPMMode</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga14afbba9f4eb5541a246f6993103c0be">AEM13920_APM_MODE</a> *mode)</td></tr>
<tr class="memdesc:ga4be229f12a95385f3eeb7ae41a736dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the configured APM mode.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga4be229f12a95385f3eeb7ae41a736dd9">More...</a><br /></td></tr>
<tr class="separator:ga4be229f12a95385f3eeb7ae41a736dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6baf3228367415fe8a3d87458514afa"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gad6baf3228367415fe8a3d87458514afa">AEM13920_SetAPMWindow</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#gaef0ae0015f6f8a0e3c47710718d5ac84">AEM13920_APM_WINDOW</a> window)</td></tr>
<tr class="memdesc:gad6baf3228367415fe8a3d87458514afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the APM computation window.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gad6baf3228367415fe8a3d87458514afa">More...</a><br /></td></tr>
<tr class="separator:gad6baf3228367415fe8a3d87458514afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3142c90829bccaa6b01d7ee274951ce8"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga3142c90829bccaa6b01d7ee274951ce8">AEM13920_GetAPMWindow</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#gaef0ae0015f6f8a0e3c47710718d5ac84">AEM13920_APM_WINDOW</a> *window)</td></tr>
<tr class="memdesc:ga3142c90829bccaa6b01d7ee274951ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the configured APM computation window.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga3142c90829bccaa6b01d7ee274951ce8">More...</a><br /></td></tr>
<tr class="separator:ga3142c90829bccaa6b01d7ee274951ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44f0fff820087885425b9f5a1ef03ba6"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga44f0fff820087885425b9f5a1ef03ba6">AEM13920_SetIRQConfig</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, const <a class="el" href="group___a_e_m13920___common.html#struct_a_e_m13920___i_r_q_e_n__t">AEM13920_IRQEN_t</a> *irqs)</td></tr>
<tr class="memdesc:ga44f0fff820087885425b9f5a1ef03ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the AEM's IRQs.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga44f0fff820087885425b9f5a1ef03ba6">More...</a><br /></td></tr>
<tr class="separator:ga44f0fff820087885425b9f5a1ef03ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fbb54c6968fcc79cd6db4b123a5c4fe"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga2fbb54c6968fcc79cd6db4b123a5c4fe">AEM13920_GetIRQConfig</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#struct_a_e_m13920___i_r_q_e_n__t">AEM13920_IRQEN_t</a> *irqs)</td></tr>
<tr class="memdesc:ga2fbb54c6968fcc79cd6db4b123a5c4fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the configuration of the IRQs.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga2fbb54c6968fcc79cd6db4b123a5c4fe">More...</a><br /></td></tr>
<tr class="separator:ga2fbb54c6968fcc79cd6db4b123a5c4fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07b567699ab2251c104e0f4287c2bb75"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga07b567699ab2251c104e0f4287c2bb75">AEM13920_EnableI2CReadyIRQ</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler)</td></tr>
<tr class="memdesc:ga07b567699ab2251c104e0f4287c2bb75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the I2CRDY IRQ.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga07b567699ab2251c104e0f4287c2bb75">More...</a><br /></td></tr>
<tr class="separator:ga07b567699ab2251c104e0f4287c2bb75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45806bc9afe8c606acde88ff147c261a"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga45806bc9afe8c606acde88ff147c261a">AEM13920_DisableI2CReadyIRQ</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler)</td></tr>
<tr class="memdesc:ga45806bc9afe8c606acde88ff147c261a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the I2CRDY IRQ.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga45806bc9afe8c606acde88ff147c261a">More...</a><br /></td></tr>
<tr class="separator:ga45806bc9afe8c606acde88ff147c261a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga205820da109c68f032db4d7140562a1f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga205820da109c68f032db4d7140562a1f">AEM13920_IsEnabledI2CReadyIRQ</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, bool *en)</td></tr>
<tr class="memdesc:ga205820da109c68f032db4d7140562a1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the enabling status of the I2CRDY IRQ.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga205820da109c68f032db4d7140562a1f">More...</a><br /></td></tr>
<tr class="separator:ga205820da109c68f032db4d7140562a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1a20f851900703ba24418b05d04e6ee"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gae1a20f851900703ba24418b05d04e6ee">AEM13920_EnableOverdischargeIRQ</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler)</td></tr>
<tr class="memdesc:gae1a20f851900703ba24418b05d04e6ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the VOVDIS IRQ.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gae1a20f851900703ba24418b05d04e6ee">More...</a><br /></td></tr>
<tr class="separator:gae1a20f851900703ba24418b05d04e6ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2619b95da5d2c215aa2bd24a3e1289d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gad2619b95da5d2c215aa2bd24a3e1289d">AEM13920_DisableOverdischargeIRQ</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler)</td></tr>
<tr class="memdesc:gad2619b95da5d2c215aa2bd24a3e1289d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the VOVDIS IRQ.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gad2619b95da5d2c215aa2bd24a3e1289d">More...</a><br /></td></tr>
<tr class="separator:gad2619b95da5d2c215aa2bd24a3e1289d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1a517bb8c3bddaeb876bbfa3b755085"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaa1a517bb8c3bddaeb876bbfa3b755085">AEM13920_IsEnabledOverdischargeIRQ</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, bool *en)</td></tr>
<tr class="memdesc:gaa1a517bb8c3bddaeb876bbfa3b755085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the enabling status of the VOVDIS IRQ.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gaa1a517bb8c3bddaeb876bbfa3b755085">More...</a><br /></td></tr>
<tr class="separator:gaa1a517bb8c3bddaeb876bbfa3b755085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc22719968236fd365da1c7957cb5b21"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gabc22719968236fd365da1c7957cb5b21">AEM13920_EnableChargeReadyIRQ</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler)</td></tr>
<tr class="memdesc:gabc22719968236fd365da1c7957cb5b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the VCHRDY IRQ.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gabc22719968236fd365da1c7957cb5b21">More...</a><br /></td></tr>
<tr class="separator:gabc22719968236fd365da1c7957cb5b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2068fc749337dedf76356bd80c5eb641"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga2068fc749337dedf76356bd80c5eb641">AEM13920_DisableChargeReadyIRQ</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler)</td></tr>
<tr class="memdesc:ga2068fc749337dedf76356bd80c5eb641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the VCHRDY IRQ.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga2068fc749337dedf76356bd80c5eb641">More...</a><br /></td></tr>
<tr class="separator:ga2068fc749337dedf76356bd80c5eb641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1df1aca75f445663bedac286846ab9a"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gad1df1aca75f445663bedac286846ab9a">AEM13920_IsEnabledChargeReadyIRQ</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, bool *en)</td></tr>
<tr class="memdesc:gad1df1aca75f445663bedac286846ab9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the enabling status of the VCHRDY IRQ.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gad1df1aca75f445663bedac286846ab9a">More...</a><br /></td></tr>
<tr class="separator:gad1df1aca75f445663bedac286846ab9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8bd3588fcd896e931cc48bc2e786ee4"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf8bd3588fcd896e931cc48bc2e786ee4">AEM13920_EnableOverchargeIRQ</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler)</td></tr>
<tr class="memdesc:gaf8bd3588fcd896e931cc48bc2e786ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable VOVCH IRQ.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gaf8bd3588fcd896e931cc48bc2e786ee4">More...</a><br /></td></tr>
<tr class="separator:gaf8bd3588fcd896e931cc48bc2e786ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e52012ebc73c24f6ccbd0bb0679d3b1"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga0e52012ebc73c24f6ccbd0bb0679d3b1">AEM13920_DisableOverchargeIRQ</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler)</td></tr>
<tr class="memdesc:ga0e52012ebc73c24f6ccbd0bb0679d3b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the VOVCH IRQ.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga0e52012ebc73c24f6ccbd0bb0679d3b1">More...</a><br /></td></tr>
<tr class="separator:ga0e52012ebc73c24f6ccbd0bb0679d3b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga774c0430c4cd229596e7a521aeaf41f9"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga774c0430c4cd229596e7a521aeaf41f9">AEM13920_IsEnabledOverchargeIRQ</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, bool *en)</td></tr>
<tr class="memdesc:ga774c0430c4cd229596e7a521aeaf41f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the enabling status of the VOVCH IRQ.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga774c0430c4cd229596e7a521aeaf41f9">More...</a><br /></td></tr>
<tr class="separator:ga774c0430c4cd229596e7a521aeaf41f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5108f7355ef58c98fa62366c8eb71866"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga5108f7355ef58c98fa62366c8eb71866">AEM13920_EnableSRCLowIRQ</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler)</td></tr>
<tr class="memdesc:ga5108f7355ef58c98fa62366c8eb71866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable SRCLOW IRQ.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga5108f7355ef58c98fa62366c8eb71866">More...</a><br /></td></tr>
<tr class="separator:ga5108f7355ef58c98fa62366c8eb71866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0102df27221ad96501df3f6a1fbd4db6"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga0102df27221ad96501df3f6a1fbd4db6">AEM13920_DisableSRCLowIRQ</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler)</td></tr>
<tr class="memdesc:ga0102df27221ad96501df3f6a1fbd4db6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the SRCLOW IRQ.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga0102df27221ad96501df3f6a1fbd4db6">More...</a><br /></td></tr>
<tr class="separator:ga0102df27221ad96501df3f6a1fbd4db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd000d6e8d1a1229d11eb9c4bbffb88b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gadd000d6e8d1a1229d11eb9c4bbffb88b">AEM13920_IsEnabledSRCLowIRQ</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, bool *en)</td></tr>
<tr class="memdesc:gadd000d6e8d1a1229d11eb9c4bbffb88b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the enabling status of the SRCLOW IRQ.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gadd000d6e8d1a1229d11eb9c4bbffb88b">More...</a><br /></td></tr>
<tr class="separator:gadd000d6e8d1a1229d11eb9c4bbffb88b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79561e76e526e985c37c011b43dd15ab"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga79561e76e526e985c37c011b43dd15ab">AEM13920_EnableTempChargeIRQ</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler)</td></tr>
<tr class="memdesc:ga79561e76e526e985c37c011b43dd15ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable TEMPCH IRQ.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga79561e76e526e985c37c011b43dd15ab">More...</a><br /></td></tr>
<tr class="separator:ga79561e76e526e985c37c011b43dd15ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f9268483b1a49aaeca9472874f9febd"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga5f9268483b1a49aaeca9472874f9febd">AEM13920_DisableTempChargeIRQ</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler)</td></tr>
<tr class="memdesc:ga5f9268483b1a49aaeca9472874f9febd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the TEMPCH IRQ.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga5f9268483b1a49aaeca9472874f9febd">More...</a><br /></td></tr>
<tr class="separator:ga5f9268483b1a49aaeca9472874f9febd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46a19e4851c2ffc0b539bcfdc685cf7e"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga46a19e4851c2ffc0b539bcfdc685cf7e">AEM13920_IsEnabledTempChargeIRQ</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, bool *en)</td></tr>
<tr class="memdesc:ga46a19e4851c2ffc0b539bcfdc685cf7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the enabling status of the TEMPCH IRQ.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga46a19e4851c2ffc0b539bcfdc685cf7e">More...</a><br /></td></tr>
<tr class="separator:ga46a19e4851c2ffc0b539bcfdc685cf7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1570082386063a2dae19dbf6ddd029ea"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga1570082386063a2dae19dbf6ddd029ea">AEM13920_EnableTempDischargeIRQ</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler)</td></tr>
<tr class="memdesc:ga1570082386063a2dae19dbf6ddd029ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable TEMPDIS IRQ.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga1570082386063a2dae19dbf6ddd029ea">More...</a><br /></td></tr>
<tr class="separator:ga1570082386063a2dae19dbf6ddd029ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02bca5f6f374aaf7c203a236b90fc3d7"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga02bca5f6f374aaf7c203a236b90fc3d7">AEM13920_DisableTempDischargeIRQ</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler)</td></tr>
<tr class="memdesc:ga02bca5f6f374aaf7c203a236b90fc3d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the TEMPDIS IRQ.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga02bca5f6f374aaf7c203a236b90fc3d7">More...</a><br /></td></tr>
<tr class="separator:ga02bca5f6f374aaf7c203a236b90fc3d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f898b819dd266af6a5fbcae73b6ba29"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga5f898b819dd266af6a5fbcae73b6ba29">AEM13920_IsEnabledTempDischargeIRQ</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, bool *en)</td></tr>
<tr class="memdesc:ga5f898b819dd266af6a5fbcae73b6ba29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the enabling status of the TEMPDIS IRQ.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga5f898b819dd266af6a5fbcae73b6ba29">More...</a><br /></td></tr>
<tr class="separator:ga5f898b819dd266af6a5fbcae73b6ba29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeef7b21964872d85c3d74945b5dd640b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaeef7b21964872d85c3d74945b5dd640b">AEM13920_EnableMPPTStartIRQ</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> src)</td></tr>
<tr class="memdesc:gaeef7b21964872d85c3d74945b5dd640b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the MPPTSTART IRQ for the selected source.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gaeef7b21964872d85c3d74945b5dd640b">More...</a><br /></td></tr>
<tr class="separator:gaeef7b21964872d85c3d74945b5dd640b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ba411b89acd3b75ec97e53b288b0a2c"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga7ba411b89acd3b75ec97e53b288b0a2c">AEM13920_DisableMPPTStartIRQ</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> src)</td></tr>
<tr class="memdesc:ga7ba411b89acd3b75ec97e53b288b0a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the MPPTSTART IRQ for the selected source.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga7ba411b89acd3b75ec97e53b288b0a2c">More...</a><br /></td></tr>
<tr class="separator:ga7ba411b89acd3b75ec97e53b288b0a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b3bd8aca148a5fdfb297efeadf971ba"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga7b3bd8aca148a5fdfb297efeadf971ba">AEM13920_IsEnabledMPPTStartIRQ</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> src, bool *en)</td></tr>
<tr class="memdesc:ga7b3bd8aca148a5fdfb297efeadf971ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the enabling status of the MPPTSTART IRQ for the selected source.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga7b3bd8aca148a5fdfb297efeadf971ba">More...</a><br /></td></tr>
<tr class="separator:ga7b3bd8aca148a5fdfb297efeadf971ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0935e0d623a8092aaf813a85776aa18d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga0935e0d623a8092aaf813a85776aa18d">AEM13920_EnableMPPTDoneIRQ</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> src)</td></tr>
<tr class="memdesc:ga0935e0d623a8092aaf813a85776aa18d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the MPPTDONE IRQ for the selected source.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga0935e0d623a8092aaf813a85776aa18d">More...</a><br /></td></tr>
<tr class="separator:ga0935e0d623a8092aaf813a85776aa18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7af7f49021f7c1fa3d8eea7e10c688d3"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga7af7f49021f7c1fa3d8eea7e10c688d3">AEM13920_DisableMPPTDoneIRQ</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> src)</td></tr>
<tr class="memdesc:ga7af7f49021f7c1fa3d8eea7e10c688d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the MPPTDONE IRQ for the selected source.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga7af7f49021f7c1fa3d8eea7e10c688d3">More...</a><br /></td></tr>
<tr class="separator:ga7af7f49021f7c1fa3d8eea7e10c688d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac337df212e729d35e05606e2806898ee"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gac337df212e729d35e05606e2806898ee">AEM13920_IsEnabledMPPTDoneIRQ</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> src, bool *en)</td></tr>
<tr class="memdesc:gac337df212e729d35e05606e2806898ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the enabling status of the MPPTDONE IRQ for the selected source.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gac337df212e729d35e05606e2806898ee">More...</a><br /></td></tr>
<tr class="separator:gac337df212e729d35e05606e2806898ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacffe976ae8ddda0ac1e6cc926f0dfe5e"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gacffe976ae8ddda0ac1e6cc926f0dfe5e">AEM13920_EnableSTODoneIRQ</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler)</td></tr>
<tr class="memdesc:gacffe976ae8ddda0ac1e6cc926f0dfe5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the STODONE IRQ.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gacffe976ae8ddda0ac1e6cc926f0dfe5e">More...</a><br /></td></tr>
<tr class="separator:gacffe976ae8ddda0ac1e6cc926f0dfe5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46f23da8407fbc778ad28b53f0c7ed72"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga46f23da8407fbc778ad28b53f0c7ed72">AEM13920_DisableSTODoneIRQ</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler)</td></tr>
<tr class="memdesc:ga46f23da8407fbc778ad28b53f0c7ed72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the STODONE IRQ.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga46f23da8407fbc778ad28b53f0c7ed72">More...</a><br /></td></tr>
<tr class="separator:ga46f23da8407fbc778ad28b53f0c7ed72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c6a4753a1d43e9dacaa9c58fe275ac0"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga5c6a4753a1d43e9dacaa9c58fe275ac0">AEM13920_IsEnabledSTODoneIRQ</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, bool *en)</td></tr>
<tr class="memdesc:ga5c6a4753a1d43e9dacaa9c58fe275ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the enabling status of the STODONE IRQ.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga5c6a4753a1d43e9dacaa9c58fe275ac0">More...</a><br /></td></tr>
<tr class="separator:ga5c6a4753a1d43e9dacaa9c58fe275ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43f81ad2c94268d39b91332143826d24"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga43f81ad2c94268d39b91332143826d24">AEM13920_EnableTempDoneIRQ</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler)</td></tr>
<tr class="memdesc:ga43f81ad2c94268d39b91332143826d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the TEMPDONE IRQ.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga43f81ad2c94268d39b91332143826d24">More...</a><br /></td></tr>
<tr class="separator:ga43f81ad2c94268d39b91332143826d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e6e9ef8c2c3e5715cc3f19a85c8ece2"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga4e6e9ef8c2c3e5715cc3f19a85c8ece2">AEM13920_DisableTempDoneIRQ</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler)</td></tr>
<tr class="memdesc:ga4e6e9ef8c2c3e5715cc3f19a85c8ece2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the TEMPDONE IRQ.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga4e6e9ef8c2c3e5715cc3f19a85c8ece2">More...</a><br /></td></tr>
<tr class="separator:ga4e6e9ef8c2c3e5715cc3f19a85c8ece2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c8290c750e110b2bbe17826ff540310"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga0c8290c750e110b2bbe17826ff540310">AEM13920_IsEnabledTempDoneIRQ</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, bool *en)</td></tr>
<tr class="memdesc:ga0c8290c750e110b2bbe17826ff540310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the enabling status of the TEMPDONE IRQ.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga0c8290c750e110b2bbe17826ff540310">More...</a><br /></td></tr>
<tr class="separator:ga0c8290c750e110b2bbe17826ff540310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bd247eb2e2dc1a3dd6c2b9486296a2e"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga9bd247eb2e2dc1a3dd6c2b9486296a2e">AEM13920_EnableAPMDoneIRQ</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler)</td></tr>
<tr class="memdesc:ga9bd247eb2e2dc1a3dd6c2b9486296a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable APMDONE IRQ.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga9bd247eb2e2dc1a3dd6c2b9486296a2e">More...</a><br /></td></tr>
<tr class="separator:ga9bd247eb2e2dc1a3dd6c2b9486296a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga932e263d4ca77adff40d5250eb15e8a8"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga932e263d4ca77adff40d5250eb15e8a8">AEM13920_DisableAPMDoneIRQ</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler)</td></tr>
<tr class="memdesc:ga932e263d4ca77adff40d5250eb15e8a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the APMDONE IRQ.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga932e263d4ca77adff40d5250eb15e8a8">More...</a><br /></td></tr>
<tr class="separator:ga932e263d4ca77adff40d5250eb15e8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69a8b2219036a6d7ee13dc36acde2ac2"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga69a8b2219036a6d7ee13dc36acde2ac2">AEM13920_IsEnabledAPMDoneIRQ</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, bool *en)</td></tr>
<tr class="memdesc:ga69a8b2219036a6d7ee13dc36acde2ac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the enabling status of the APMDONE IRQ.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga69a8b2219036a6d7ee13dc36acde2ac2">More...</a><br /></td></tr>
<tr class="separator:ga69a8b2219036a6d7ee13dc36acde2ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c72bcb6ec638ab6231b7f09d52a2b96"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga7c72bcb6ec638ab6231b7f09d52a2b96">AEM13920_EnableAPMErrIRQ</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler)</td></tr>
<tr class="memdesc:ga7c72bcb6ec638ab6231b7f09d52a2b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the APMERR IRQ.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga7c72bcb6ec638ab6231b7f09d52a2b96">More...</a><br /></td></tr>
<tr class="separator:ga7c72bcb6ec638ab6231b7f09d52a2b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2f63da50b811cbc33af1a3ee5c70249"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaa2f63da50b811cbc33af1a3ee5c70249">AEM13920_DisableAPMErrIRQ</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler)</td></tr>
<tr class="memdesc:gaa2f63da50b811cbc33af1a3ee5c70249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the APMERR IRQ.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gaa2f63da50b811cbc33af1a3ee5c70249">More...</a><br /></td></tr>
<tr class="separator:gaa2f63da50b811cbc33af1a3ee5c70249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae46fe8b8aab9586546cd0d4151b39bd5"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gae46fe8b8aab9586546cd0d4151b39bd5">AEM13920_IsEnabledAPMErrIRQ</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, bool *en)</td></tr>
<tr class="memdesc:gae46fe8b8aab9586546cd0d4151b39bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the enabling status of the APMERR IRQ.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gae46fe8b8aab9586546cd0d4151b39bd5">More...</a><br /></td></tr>
<tr class="separator:gae46fe8b8aab9586546cd0d4151b39bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9b31c72036572a080787a83e0c86e69"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaa9b31c72036572a080787a83e0c86e69">AEM13920_SetConfigurationMode</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga1f8360223fa5e4657b6bfd75107e9653">AEM13920_CONFIG_MODE</a> mode)</td></tr>
<tr class="memdesc:gaa9b31c72036572a080787a83e0c86e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the configuration mode (I2C or GPIO)  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gaa9b31c72036572a080787a83e0c86e69">More...</a><br /></td></tr>
<tr class="separator:gaa9b31c72036572a080787a83e0c86e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacad1361d510337c7cb2aff2ec7c706d0"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gacad1361d510337c7cb2aff2ec7c706d0">AEM13920_GetConfigurationMode</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga1f8360223fa5e4657b6bfd75107e9653">AEM13920_CONFIG_MODE</a> *mode)</td></tr>
<tr class="memdesc:gacad1361d510337c7cb2aff2ec7c706d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the active configuration mode (I2C or GPIO)  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gacad1361d510337c7cb2aff2ec7c706d0">More...</a><br /></td></tr>
<tr class="separator:gacad1361d510337c7cb2aff2ec7c706d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b9937cb783cd9118b630f6cd8b6b9b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b">AEM13920_SyncI2CConfiguration</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, bool blocking)</td></tr>
<tr class="memdesc:gaf9b9937cb783cd9118b630f6cd8b6b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the I2C configuration.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b">More...</a><br /></td></tr>
<tr class="separator:gaf9b9937cb783cd9118b630f6cd8b6b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabda7c3d01846fc9825dcfff754770422"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gabda7c3d01846fc9825dcfff754770422">AEM13920_IsSyncingI2CConfiguration</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, bool *syncing)</td></tr>
<tr class="memdesc:gabda7c3d01846fc9825dcfff754770422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the I2C synchronization busy flag.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gabda7c3d01846fc9825dcfff754770422">More...</a><br /></td></tr>
<tr class="separator:gabda7c3d01846fc9825dcfff754770422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10f70e674915c959362ad7fa24855030"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga10f70e674915c959362ad7fa24855030">AEM13920_GetChipVersion</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, uint8_t *version)</td></tr>
<tr class="memdesc:ga10f70e674915c959362ad7fa24855030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the chip version.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga10f70e674915c959362ad7fa24855030">More...</a><br /></td></tr>
<tr class="separator:ga10f70e674915c959362ad7fa24855030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b84b275a2a8db80371977860e695863"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga9b84b275a2a8db80371977860e695863">AEM13920_GetIRQFlags</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#struct_a_e_m13920___i_r_q_f_l_g__t">AEM13920_IRQFLG_t</a> *flags)</td></tr>
<tr class="memdesc:ga9b84b275a2a8db80371977860e695863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the AEM's interrupt flags.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga9b84b275a2a8db80371977860e695863">More...</a><br /></td></tr>
<tr class="separator:ga9b84b275a2a8db80371977860e695863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac72074e1960978dcb49c39fee7f5fa45"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gac72074e1960978dcb49c39fee7f5fa45">AEM13920_GetI2CReadyFlag</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, bool *flag)</td></tr>
<tr class="memdesc:gac72074e1960978dcb49c39fee7f5fa45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the I2C ready IRQ flag.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gac72074e1960978dcb49c39fee7f5fa45">More...</a><br /></td></tr>
<tr class="separator:gac72074e1960978dcb49c39fee7f5fa45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4a483850182599b77642b1cde5971e2"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gae4a483850182599b77642b1cde5971e2">AEM13920_GetOverdischargeFlag</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, bool *flag)</td></tr>
<tr class="memdesc:gae4a483850182599b77642b1cde5971e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the overdischarge IRQ flag.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gae4a483850182599b77642b1cde5971e2">More...</a><br /></td></tr>
<tr class="separator:gae4a483850182599b77642b1cde5971e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ac5f9860f58bd601b7d703c818e9666"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga8ac5f9860f58bd601b7d703c818e9666">AEM13920_GetChargeReadyFlag</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, bool *flag)</td></tr>
<tr class="memdesc:ga8ac5f9860f58bd601b7d703c818e9666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the charge ready IRQ flag.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga8ac5f9860f58bd601b7d703c818e9666">More...</a><br /></td></tr>
<tr class="separator:ga8ac5f9860f58bd601b7d703c818e9666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa146248af14c5313b39dc38b4b2aadb5"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaa146248af14c5313b39dc38b4b2aadb5">AEM13920_GetOverchargeFlag</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, bool *flag)</td></tr>
<tr class="memdesc:gaa146248af14c5313b39dc38b4b2aadb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the overcharge IRQ flag.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gaa146248af14c5313b39dc38b4b2aadb5">More...</a><br /></td></tr>
<tr class="separator:gaa146248af14c5313b39dc38b4b2aadb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d3d44f9a8b8cfba2593a80461ed1bb4"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga9d3d44f9a8b8cfba2593a80461ed1bb4">AEM13920_GetSRCLowFlag</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, bool *flag)</td></tr>
<tr class="memdesc:ga9d3d44f9a8b8cfba2593a80461ed1bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the SRCLOW IRQ flag.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga9d3d44f9a8b8cfba2593a80461ed1bb4">More...</a><br /></td></tr>
<tr class="separator:ga9d3d44f9a8b8cfba2593a80461ed1bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76bbc3a8ef432961e49edbbc7e76ba48"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga76bbc3a8ef432961e49edbbc7e76ba48">AEM13920_GetTempChargeFlag</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, bool *flag)</td></tr>
<tr class="memdesc:ga76bbc3a8ef432961e49edbbc7e76ba48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the temperature (charge) IRQ flag.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga76bbc3a8ef432961e49edbbc7e76ba48">More...</a><br /></td></tr>
<tr class="separator:ga76bbc3a8ef432961e49edbbc7e76ba48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade215d0e45a3ca4aba945b790bf9c21f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gade215d0e45a3ca4aba945b790bf9c21f">AEM13920_GetTempDischargeFlag</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, bool *flag)</td></tr>
<tr class="memdesc:gade215d0e45a3ca4aba945b790bf9c21f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the temperature (discharge) IRQ flag.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gade215d0e45a3ca4aba945b790bf9c21f">More...</a><br /></td></tr>
<tr class="separator:gade215d0e45a3ca4aba945b790bf9c21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8829e15fe5a5b3a344c4fcfe4faea223"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga8829e15fe5a5b3a344c4fcfe4faea223">AEM13920_GetMPPTStartFlag</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> src, bool *flag)</td></tr>
<tr class="memdesc:ga8829e15fe5a5b3a344c4fcfe4faea223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the MPPT Start IRQ flag for the selected source.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga8829e15fe5a5b3a344c4fcfe4faea223">More...</a><br /></td></tr>
<tr class="separator:ga8829e15fe5a5b3a344c4fcfe4faea223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga188e88a4d228017f9cf29b9526931dce"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga188e88a4d228017f9cf29b9526931dce">AEM13920_GetMPPTDoneFlag</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> src, bool *flag)</td></tr>
<tr class="memdesc:ga188e88a4d228017f9cf29b9526931dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the MPPT Done IRQ flag for the selected source.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga188e88a4d228017f9cf29b9526931dce">More...</a><br /></td></tr>
<tr class="separator:ga188e88a4d228017f9cf29b9526931dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf3f28881283620fdde926136cace2eb"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gacf3f28881283620fdde926136cace2eb">AEM13920_GetSTODoneFlag</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, bool *flag)</td></tr>
<tr class="memdesc:gacf3f28881283620fdde926136cace2eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the STO Done IRQ flag.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gacf3f28881283620fdde926136cace2eb">More...</a><br /></td></tr>
<tr class="separator:gacf3f28881283620fdde926136cace2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5bfa6fb917854228a2b783f3b0b257a"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gac5bfa6fb917854228a2b783f3b0b257a">AEM13920_GetTempDoneFlag</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, bool *flag)</td></tr>
<tr class="memdesc:gac5bfa6fb917854228a2b783f3b0b257a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the TEMP Done IRQ flag.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gac5bfa6fb917854228a2b783f3b0b257a">More...</a><br /></td></tr>
<tr class="separator:gac5bfa6fb917854228a2b783f3b0b257a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae25b3dc3b1b427dab507d62807343dab"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gae25b3dc3b1b427dab507d62807343dab">AEM13920_GetAPMDoneFlag</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, bool *flag)</td></tr>
<tr class="memdesc:gae25b3dc3b1b427dab507d62807343dab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the APM done IRQ flag.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gae25b3dc3b1b427dab507d62807343dab">More...</a><br /></td></tr>
<tr class="separator:gae25b3dc3b1b427dab507d62807343dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedc48ba39724569c3664cfc534cc4ae7"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaedc48ba39724569c3664cfc534cc4ae7">AEM13920_GetAPMErrFlag</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, bool *flag)</td></tr>
<tr class="memdesc:gaedc48ba39724569c3664cfc534cc4ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the APM error IRQ flag.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gaedc48ba39724569c3664cfc534cc4ae7">More...</a><br /></td></tr>
<tr class="separator:gaedc48ba39724569c3664cfc534cc4ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e0379f86dc35d0c9891dd9d5421d6a2"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga3e0379f86dc35d0c9891dd9d5421d6a2">AEM13920_GetStatus</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#struct_a_e_m13920___s_t_a_t_u_s__t">AEM13920_STATUS_t</a> *status)</td></tr>
<tr class="memdesc:ga3e0379f86dc35d0c9891dd9d5421d6a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the AEM's status.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga3e0379f86dc35d0c9891dd9d5421d6a2">More...</a><br /></td></tr>
<tr class="separator:ga3e0379f86dc35d0c9891dd9d5421d6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e9efd1cddda0fb049cfc2f94d8d14c9"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga6e9efd1cddda0fb049cfc2f94d8d14c9">AEM13920_GetOverdischargeStatus</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, bool *status)</td></tr>
<tr class="memdesc:ga6e9efd1cddda0fb049cfc2f94d8d14c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the overdischarge status.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga6e9efd1cddda0fb049cfc2f94d8d14c9">More...</a><br /></td></tr>
<tr class="separator:ga6e9efd1cddda0fb049cfc2f94d8d14c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09333d5d55d49d260872ebf2baf5d061"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga09333d5d55d49d260872ebf2baf5d061">AEM13920_GetChargeReadyStatus</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, bool *status)</td></tr>
<tr class="memdesc:ga09333d5d55d49d260872ebf2baf5d061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the charge ready status.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga09333d5d55d49d260872ebf2baf5d061">More...</a><br /></td></tr>
<tr class="separator:ga09333d5d55d49d260872ebf2baf5d061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d34961b9367a6278a93ddbcddf183cf"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga7d34961b9367a6278a93ddbcddf183cf">AEM13920_GetOverchargeStatus</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, bool *status)</td></tr>
<tr class="memdesc:ga7d34961b9367a6278a93ddbcddf183cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the overcharge status.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga7d34961b9367a6278a93ddbcddf183cf">More...</a><br /></td></tr>
<tr class="separator:ga7d34961b9367a6278a93ddbcddf183cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e178f09d7bba60ad49543cd97abfd5a"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga6e178f09d7bba60ad49543cd97abfd5a">AEM13920_GetSRCLowStatus</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> src, bool *status)</td></tr>
<tr class="memdesc:ga6e178f09d7bba60ad49543cd97abfd5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the SRC Threshold status for the selected source.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga6e178f09d7bba60ad49543cd97abfd5a">More...</a><br /></td></tr>
<tr class="separator:ga6e178f09d7bba60ad49543cd97abfd5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0abf90472f055d5c3c46248ac3a34889"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga0abf90472f055d5c3c46248ac3a34889">AEM13920_GetTempHotChargeStatus</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, bool *status)</td></tr>
<tr class="memdesc:ga0abf90472f055d5c3c46248ac3a34889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the status of the hot temperature threshold (charge)  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga0abf90472f055d5c3c46248ac3a34889">More...</a><br /></td></tr>
<tr class="separator:ga0abf90472f055d5c3c46248ac3a34889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d30be1886753e00f91aa23d8e43c44d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga0d30be1886753e00f91aa23d8e43c44d">AEM13920_GetTempHotDischargeStatus</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, bool *status)</td></tr>
<tr class="memdesc:ga0d30be1886753e00f91aa23d8e43c44d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the status of the hot temperature threshold (discharge)  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga0d30be1886753e00f91aa23d8e43c44d">More...</a><br /></td></tr>
<tr class="separator:ga0d30be1886753e00f91aa23d8e43c44d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga583ba59e1e748ba4cbaaeb03c402899a"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga583ba59e1e748ba4cbaaeb03c402899a">AEM13920_GetTempColdChargeStatus</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, bool *status)</td></tr>
<tr class="memdesc:ga583ba59e1e748ba4cbaaeb03c402899a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the status of the cold temperature threshold (charge)  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga583ba59e1e748ba4cbaaeb03c402899a">More...</a><br /></td></tr>
<tr class="separator:ga583ba59e1e748ba4cbaaeb03c402899a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga781bb22db8e5690cdfff89d40f569a13"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga781bb22db8e5690cdfff89d40f569a13">AEM13920_GetTempColdDischargeStatus</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, bool *status)</td></tr>
<tr class="memdesc:ga781bb22db8e5690cdfff89d40f569a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the status of the cold temperature threshold (discharge)  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga781bb22db8e5690cdfff89d40f569a13">More...</a><br /></td></tr>
<tr class="separator:ga781bb22db8e5690cdfff89d40f569a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab59dc68322310fedce7d22b5c6fa7f0"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaab59dc68322310fedce7d22b5c6fa7f0">AEM13920_GetAPMSourceData</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> src, uint64_t *data)</td></tr>
<tr class="memdesc:gaab59dc68322310fedce7d22b5c6fa7f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the APM data for the specified source.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gaab59dc68322310fedce7d22b5c6fa7f0">More...</a><br /></td></tr>
<tr class="separator:gaab59dc68322310fedce7d22b5c6fa7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75adee989e9522ef4db3f141a28d0af1"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga75adee989e9522ef4db3f141a28d0af1">AEM13920_GetAPMBuckData</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, uint64_t *data)</td></tr>
<tr class="memdesc:ga75adee989e9522ef4db3f141a28d0af1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the APM data.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga75adee989e9522ef4db3f141a28d0af1">More...</a><br /></td></tr>
<tr class="separator:ga75adee989e9522ef4db3f141a28d0af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecd265ceb6552c2ef5727da30dbe4c0b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaecd265ceb6552c2ef5727da30dbe4c0b">AEM13920_GetAPMErrors</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#struct_a_e_m13920___a_p_m_e_r_r__t">AEM13920_APMERR_t</a> *errors)</td></tr>
<tr class="memdesc:gaecd265ceb6552c2ef5727da30dbe4c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the APM errors.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gaecd265ceb6552c2ef5727da30dbe4c0b">More...</a><br /></td></tr>
<tr class="separator:gaecd265ceb6552c2ef5727da30dbe4c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8069b4035eabd04b76c94453c5bf9850"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga8069b4035eabd04b76c94453c5bf9850">AEM13920_IsAPMSourceOverflow</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> src, bool *error)</td></tr>
<tr class="memdesc:ga8069b4035eabd04b76c94453c5bf9850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether an APM counter overflow occured for the specified source.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga8069b4035eabd04b76c94453c5bf9850">More...</a><br /></td></tr>
<tr class="separator:ga8069b4035eabd04b76c94453c5bf9850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9eeb9632af2ff4a538be9c8d7bf3d3ea"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga9eeb9632af2ff4a538be9c8d7bf3d3ea">AEM13920_IsAPMSourceCorrupted</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> src, bool *error)</td></tr>
<tr class="memdesc:ga9eeb9632af2ff4a538be9c8d7bf3d3ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether the APM data for the selected source is corrupted.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga9eeb9632af2ff4a538be9c8d7bf3d3ea">More...</a><br /></td></tr>
<tr class="separator:ga9eeb9632af2ff4a538be9c8d7bf3d3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac949ef97f362f7becce2ee11e3a62ed8"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gac949ef97f362f7becce2ee11e3a62ed8">AEM13920_IsAPMBuckOverflow</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, bool *error)</td></tr>
<tr class="memdesc:gac949ef97f362f7becce2ee11e3a62ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether an APM counter overflow occured for the buck converter.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gac949ef97f362f7becce2ee11e3a62ed8">More...</a><br /></td></tr>
<tr class="separator:gac949ef97f362f7becce2ee11e3a62ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d60b1539d300ac1ce5798ab71c7d878"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga8d60b1539d300ac1ce5798ab71c7d878">AEM13920_IsAPMBuckCorrupted</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, bool *error)</td></tr>
<tr class="memdesc:ga8d60b1539d300ac1ce5798ab71c7d878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether the APM data for the buck converter is corrupted.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga8d60b1539d300ac1ce5798ab71c7d878">More...</a><br /></td></tr>
<tr class="separator:ga8d60b1539d300ac1ce5798ab71c7d878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa016914b213488da6e54747b18fdafef"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaa016914b213488da6e54747b18fdafef">AEM13920_GetThermistorZ</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, uint32_t rdiv, uint64_t *rth)</td></tr>
<tr class="memdesc:gaa016914b213488da6e54747b18fdafef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the thermistor's impedance.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gaa016914b213488da6e54747b18fdafef">More...</a><br /></td></tr>
<tr class="separator:gaa016914b213488da6e54747b18fdafef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f4cee89d2c024184d7dffc2d9767d48"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga1f4cee89d2c024184d7dffc2d9767d48">AEM13920_GetStorageVoltage</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, uint32_t *vsto)</td></tr>
<tr class="memdesc:ga1f4cee89d2c024184d7dffc2d9767d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the storage voltage.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga1f4cee89d2c024184d7dffc2d9767d48">More...</a><br /></td></tr>
<tr class="separator:ga1f4cee89d2c024184d7dffc2d9767d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88f3ce80d24d35b0873e1f11163c36e2"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga88f3ce80d24d35b0873e1f11163c36e2">AEM13920_SetConfiguration</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___c_o_n_f_i_g__t">AEM13920_CONFIG_t</a> *cfg, bool blocking)</td></tr>
<tr class="memdesc:ga88f3ce80d24d35b0873e1f11163c36e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the whole configuration and update the AEM accordingly.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#ga88f3ce80d24d35b0873e1f11163c36e2">More...</a><br /></td></tr>
<tr class="separator:ga88f3ce80d24d35b0873e1f11163c36e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac81ebab814f095bdd6fdf8c642c43441"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gac81ebab814f095bdd6fdf8c642c43441">AEM13920_GetConfiguration</a> (const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *handler, <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___c_o_n_f_i_g__t">AEM13920_CONFIG_t</a> *cfg)</td></tr>
<tr class="memdesc:gac81ebab814f095bdd6fdf8c642c43441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the whole AEM configuration.  <a href="group___h_a_l___a_e_m13920___a_p_i.html#gac81ebab814f095bdd6fdf8c642c43441">More...</a><br /></td></tr>
<tr class="separator:gac81ebab814f095bdd6fdf8c642c43441"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="struct_a_e_m13920___handler__t" id="struct_a_e_m13920___handler__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_a_e_m13920___handler__t">&#9670;&nbsp;</a></span>AEM13920_Handler_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct AEM13920_Handler_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p >AEM13920 handler. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a7dbdc63d3406dce0a891f8094d96a6bb" name="a7dbdc63d3406dce0a891f8094d96a6bb"></a><a class="el" href="struct_a_e_m__i2c__cfg.html">AEM_i2c_cfg</a> *</td>
<td class="fieldname">
i2c_cfg</td>
<td class="fielddoc">
Communication interface's required information. </td></tr>
<tr><td class="fieldtype">
<a id="a1715fface3946a4bf3ca1033ff8db970" name="a1715fface3946a4bf3ca1033ff8db970"></a>uint8_t</td>
<td class="fieldname">
revision</td>
<td class="fielddoc">
Revision. </td></tr>
</table>

</div>
</div>
<a name="struct_a_e_m13920___c_o_n_f_i_g__t" id="struct_a_e_m13920___c_o_n_f_i_g__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_a_e_m13920___c_o_n_f_i_g__t">&#9670;&nbsp;</a></span>AEM13920_CONFIG_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct AEM13920_CONFIG_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p >AEM13920's configuration settings. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a5228b2dd03062eb96c84b1d634d10a77" name="a5228b2dd03062eb96c84b1d634d10a77"></a><a class="el" href="group___a_e_m13920___common.html#ga14afbba9f4eb5541a246f6993103c0be">AEM13920_APM_MODE</a></td>
<td class="fieldname">
apm_mode</td>
<td class="fielddoc">
Average Power Monitoring operation mode. <dl class="section note"><dt>Note</dt><dd>This setting is only required when using the Average Power Monitoring feature. </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a id="a9ab29cc593f6d06626c97a397bf25e23" name="a9ab29cc593f6d06626c97a397bf25e23"></a><a class="el" href="group___a_e_m13920___common.html#gaef0ae0015f6f8a0e3c47710718d5ac84">AEM13920_APM_WINDOW</a></td>
<td class="fieldname">
apm_window</td>
<td class="fielddoc">
Computation window for the Average Power Monitoring. <dl class="section note"><dt>Note</dt><dd>This setting is only required when using the Average Power Monitoring feature. </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a id="a5e3eae06602912a8627eb410dc52b597" name="a5e3eae06602912a8627eb410dc52b597"></a>bool</td>
<td class="fieldname">
apm_src1_enable</td>
<td class="fielddoc">
Enable/Disable the Average Power Monitoring for SRC1. <p >Set to <code>true</code> to enable, to <code>false</code> to disable </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a9bd24794976c34b7325768371322c099" name="a9bd24794976c34b7325768371322c099"></a>bool</td>
<td class="fieldname">
apm_src2_enable</td>
<td class="fielddoc">
Enable/Disable the Average Power Monitoring for SRC2. <p >Set to <code>true</code> to enable, to <code>false</code> to disable </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aca297815933444e99deaba50fd05974e" name="aca297815933444e99deaba50fd05974e"></a>bool</td>
<td class="fieldname">
apm_buck_enable</td>
<td class="fielddoc">
Enable/Disable the Average Power Monitoring for the buck. <p >Set to <code>true</code> to enable, to <code>false</code> to disable </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aadf5760c628f8db70c17a42dcef16b4a" name="aadf5760c628f8db70c17a42dcef16b4a"></a>bool</td>
<td class="fieldname">
apm_done_irq_enable</td>
<td class="fielddoc">
Enable/Disable the IRQ pin to be asserted (HIGH) when new APM data are available. <p >Set to <code>true</code> to enable, to <code>false</code> to disable </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a32425afa6de90c7b7e7406d3ac41fb3d" name="a32425afa6de90c7b7e7406d3ac41fb3d"></a>bool</td>
<td class="fieldname">
apm_err_irq_enable</td>
<td class="fielddoc">
Enable/Disable the IRQ pin to be asserted (HIGH) when an APM error occurs. <p >Set to <code>true</code> to enable, to <code>false</code> to disable </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aa2c59fadefe60ad03102843229282bc1" name="aa2c59fadefe60ad03102843229282bc1"></a>bool</td>
<td class="fieldname">
i2c_rdy_irq_enable</td>
<td class="fielddoc">
Enable/Disable the IRQ pin to be asserted (HIGH) when the AEM is out of reset and ready to communicate through I2C. <p >Set to <code>true</code> to enable, to <code>false</code> to disable </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a9e2af4dfca55288b86f4410f0f807505" name="a9e2af4dfca55288b86f4410f0f807505"></a>bool</td>
<td class="fieldname">
src_low_irq_enable</td>
<td class="fielddoc">
Enable/Disable the IRQ pin to be asserted (HIGH) on any transition between a state where at least one source voltage is above its low threshold and a state where both are below their respective thresholds. <p >Set to <code>true</code> to enable, to <code>false</code> to disable </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ae1a73a586b25cb0666774b4978491ae6" name="ae1a73a586b25cb0666774b4978491ae6"></a><a class="el" href="group___a_e_m13920___common.html#ga77893383a955ca777943627c7fe48f4a">AEM13920_SRCLOW_THRESH</a></td>
<td class="fieldname">
src1_low_thresh</td>
<td class="fielddoc">
SRC1 Low threshold. <p >Set the SRC1 voltage below which the AEM enters SLEEP STATE </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a84224391a86cd7fb9b7dc6f0911a1c28" name="a84224391a86cd7fb9b7dc6f0911a1c28"></a><a class="el" href="group___a_e_m13920___common.html#ga77893383a955ca777943627c7fe48f4a">AEM13920_SRCLOW_THRESH</a></td>
<td class="fieldname">
src2_low_thresh</td>
<td class="fielddoc">
SRC2 Low threshold. <p >Set the SRC2 voltage below which the AEM enters SLEEP STATE </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ac34d762d0509ad9a09bbbea649383a35" name="ac34d762d0509ad9a09bbbea649383a35"></a><a class="el" href="group___a_e_m13920___common.html#gacb18d945a027bcda7a2f30ea0103f2b5">AEM13920_SRCREGU_MODE</a></td>
<td class="fieldname">
src1_regu_mode</td>
<td class="fielddoc">
SRC1 Regulation mode. <p >Set the SRC1 regulation mode </p>
</td></tr>
<tr><td class="fieldtype">
<a id="afac9e7d6b4e2055e99ec483df39c869a" name="afac9e7d6b4e2055e99ec483df39c869a"></a>uint32_t</td>
<td class="fieldname">
src1_const_voltage</td>
<td class="fielddoc">
SRC1 Regulation Voltage (mV) <p >Set the SRC1 regulation voltage </p><dl class="section warning"><dt>Warning</dt><dd>This setting is only used when the SRC1's regulation mode is set to constant voltage </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a id="a47059f46495ab72f32d0f715f3e1fa40" name="a47059f46495ab72f32d0f715f3e1fa40"></a><a class="el" href="group___a_e_m13920___common.html#ga7d6badc834d624377918cb765257eb21">AEM13920_MPPT_RATIO</a></td>
<td class="fieldname">
src1_mppt_ratio</td>
<td class="fielddoc">
MPPT ratio. <p >Set the SRC1 Maximum Power Point tracking ratio </p><dl class="section warning"><dt>Warning</dt><dd>This setting is only used when the SRC1's regulation mode is set to MPPT </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a id="ae1ea5a4833f65d1cd2b0f0d5172748c9" name="ae1ea5a4833f65d1cd2b0f0d5172748c9"></a><a class="el" href="group___a_e_m13920___common.html#gaa2752ec46c5474b8438482c31f542bd9">AEM13920_MPPT_DURATION</a></td>
<td class="fieldname">
src1_mppt_duration</td>
<td class="fielddoc">
MPPT duration. <p >Set the SRC1 Maximum Power Point Tracking duration </p><dl class="section warning"><dt>Warning</dt><dd>This setting is only used when the SRC1's regulation mode is set to MPPT </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a id="af651d78009ea30758b416eb9a4517d83" name="af651d78009ea30758b416eb9a4517d83"></a><a class="el" href="group___a_e_m13920___common.html#ga74be84c7513ff30f51bedfe7c254c0be">AEM13920_MPPT_PERIOD</a></td>
<td class="fieldname">
src1_mppt_period</td>
<td class="fielddoc">
MPPT period. <p >Set the SRC1 Maximum Power Point Tracking period </p><dl class="section warning"><dt>Warning</dt><dd>This setting is only used when the SRC1's regulation mode is set to MPPT </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a id="a3e6e4f223ec0d5f598c0cedbc4b19aa1" name="a3e6e4f223ec0d5f598c0cedbc4b19aa1"></a>bool</td>
<td class="fieldname">
src1_mppt_start_irq_enable</td>
<td class="fielddoc">
Enable/Disable the IRQ pin to be asserted (HIGH) when the MPPT starts for SRC1. <p >Set to <code>true</code> to enable, to <code>false</code> to disable </p>
</td></tr>
<tr><td class="fieldtype">
<a id="af2798317c87d13371a7e9269ff6e4f87" name="af2798317c87d13371a7e9269ff6e4f87"></a>bool</td>
<td class="fieldname">
src1_mppt_done_irq_enable</td>
<td class="fielddoc">
Enable/Disable the IRQ pin to be asserted (HIGH) when the MPPT is done for SRC1. <p >Set to <code>true</code> to enable, to <code>false</code> to disable </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a5ce6a18bbb90a391acafc5b352caefa8" name="a5ce6a18bbb90a391acafc5b352caefa8"></a>bool</td>
<td class="fieldname">
src1_boost_enable</td>
<td class="fielddoc">
Enable/Disable the SRC1 boost converter. <p >Set to <code>true</code> to enable, to <code>false</code> to disable </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a3af6dc233e43dcd58c1c840c1bd04424" name="a3af6dc233e43dcd58c1c840c1bd04424"></a>bool</td>
<td class="fieldname">
src1_boost_high_power_enable</td>
<td class="fielddoc">
Enable/Disable the High Power feature for the SRC1 boost converter. <p >Set to <code>true</code> to enable, to <code>false</code> to disable </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ae17a23650aa1a6aaf44262edc5298fdf" name="ae17a23650aa1a6aaf44262edc5298fdf"></a><a class="el" href="group___a_e_m13920___common.html#gaf5a0206be099bb00343f8142ed830d8c">AEM13920_TMULT</a></td>
<td class="fieldname">
src1_boost_tmult</td>
<td class="fielddoc">
SRC1 boost converter's timing multiplier. <p >Set the timing multiplier for the SRC1 boost converter. The higher the timing multiplier, the higher the average source current pulled from the SRC1 to charge the storage element </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ae502c8bbc984a0a8d919e2e68314b4c2" name="ae502c8bbc984a0a8d919e2e68314b4c2"></a><a class="el" href="group___a_e_m13920___common.html#gacb18d945a027bcda7a2f30ea0103f2b5">AEM13920_SRCREGU_MODE</a></td>
<td class="fieldname">
src2_regu_mode</td>
<td class="fielddoc">
SRC2 Regulation mode. <p >Set the SRC2 regulation mode </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a88075eca638b4c3b268525740ad10170" name="a88075eca638b4c3b268525740ad10170"></a>uint32_t</td>
<td class="fieldname">
src2_const_voltage</td>
<td class="fielddoc">
SRC2 Regulation Voltage (mV) <p >Set the SRC2 regulation voltage </p><dl class="section warning"><dt>Warning</dt><dd>This setting is only used when the SRC2's regulation mode is set to constant voltage </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a id="a03a2e333fc223521a5339410d1e05c05" name="a03a2e333fc223521a5339410d1e05c05"></a><a class="el" href="group___a_e_m13920___common.html#ga7d6badc834d624377918cb765257eb21">AEM13920_MPPT_RATIO</a></td>
<td class="fieldname">
src2_mppt_ratio</td>
<td class="fielddoc">
MPPT ratio. <p >Set the SRC2 Maximum Power Point tracking ratio </p><dl class="section warning"><dt>Warning</dt><dd>This setting is only used when the SRC2's regulation mode is set to MPPT </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a id="ac15e87c916d75bcec76084acd768b0f5" name="ac15e87c916d75bcec76084acd768b0f5"></a><a class="el" href="group___a_e_m13920___common.html#gaa2752ec46c5474b8438482c31f542bd9">AEM13920_MPPT_DURATION</a></td>
<td class="fieldname">
src2_mppt_duration</td>
<td class="fielddoc">
MPPT duration. <p >Set the SRC2 Maximum Power Point Tracking duration </p><dl class="section warning"><dt>Warning</dt><dd>This setting is only used when the SRC2's regulation mode is set to MPPT </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a id="aebe226bd2bdff385e45c222fdd3ee0d2" name="aebe226bd2bdff385e45c222fdd3ee0d2"></a><a class="el" href="group___a_e_m13920___common.html#ga74be84c7513ff30f51bedfe7c254c0be">AEM13920_MPPT_PERIOD</a></td>
<td class="fieldname">
src2_mppt_period</td>
<td class="fielddoc">
MPPT period. <p >Set the SRC2 Maximum Power Point Tracking period </p><dl class="section warning"><dt>Warning</dt><dd>This setting is only used when the SRC2's regulation mode is set to MPPT </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a id="ad20702640f8393e2fd1c61bbb77ac2bc" name="ad20702640f8393e2fd1c61bbb77ac2bc"></a>bool</td>
<td class="fieldname">
src2_mppt_start_irq_enable</td>
<td class="fielddoc">
Enable/Disable the IRQ pin to be asserted (HIGH) when the MPPT starts for SRC2. <p >Set to <code>true</code> to enable, to <code>false</code> to disable </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a46863d7dcb2d36b312f13010d81d9a25" name="a46863d7dcb2d36b312f13010d81d9a25"></a>bool</td>
<td class="fieldname">
src2_mppt_done_irq_enable</td>
<td class="fielddoc">
Enable/Disable the IRQ pin to be asserted (HIGH) when the MPPT is done for SRC2. <p >Set to <code>true</code> to enable, to <code>false</code> to disable </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aa78225370021279473c5b364731e4b6d" name="aa78225370021279473c5b364731e4b6d"></a>bool</td>
<td class="fieldname">
src2_boost_enable</td>
<td class="fielddoc">
Enable/Disable the SRC2 boost converter. <p >Set to <code>true</code> to enable, to <code>false</code> to disable </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ad7164e7aab148c183bf8fed8429014ae" name="ad7164e7aab148c183bf8fed8429014ae"></a>bool</td>
<td class="fieldname">
src2_boost_high_power_enable</td>
<td class="fielddoc">
Enable/Disable the High Power feature for the SRC2 boost converter. <p >Set to <code>true</code> to enable, to <code>false</code> to disable </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a0e0e9a039c2380aab45897f773ac2e44" name="a0e0e9a039c2380aab45897f773ac2e44"></a><a class="el" href="group___a_e_m13920___common.html#gaf5a0206be099bb00343f8142ed830d8c">AEM13920_TMULT</a></td>
<td class="fieldname">
src2_boost_tmult</td>
<td class="fielddoc">
SRC2 boost converter's timing multiplier. <p >Set the timing multiplier for the SRC2 boost converter. The higher the timing multiplier, the higher the average source current pulled from the SRC2 to charge the storage element </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a7eedfe3b96121775339ba71a1eb23134" name="a7eedfe3b96121775339ba71a1eb23134"></a><a class="el" href="group___a_e_m13920___common.html#gabd96065f60e993d0a866343dfcacb1fb">AEM13920_VOUT</a></td>
<td class="fieldname">
buck_vout</td>
<td class="fielddoc">
Buck converter output regulation voltage (mV) <p >Set the buck converter output regulation voltage </p>
</td></tr>
<tr><td class="fieldtype">
<a id="af2bb95980083064a92f05269e8da442e" name="af2bb95980083064a92f05269e8da442e"></a><a class="el" href="group___a_e_m13920___common.html#gaf5a0206be099bb00343f8142ed830d8c">AEM13920_TMULT</a></td>
<td class="fieldname">
buck_tmult</td>
<td class="fielddoc">
Buck converter's timing multiplier. <p >Set the timing multiplier for the buck converter </p>
</td></tr>
<tr><td class="fieldtype">
<a id="af9461ab5e5d37c5ea00dfa6fb3127b98" name="af9461ab5e5d37c5ea00dfa6fb3127b98"></a>uint32_t</td>
<td class="fieldname">
vovdis</td>
<td class="fielddoc">
Overdischarge (VOVDIS) voltage threshold. <p >Minimum voltage accepted on the storage element before stopping to supply the LOAD (mV) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a85391511ed7d3b361202234ad127b8b0" name="a85391511ed7d3b361202234ad127b8b0"></a>uint32_t</td>
<td class="fieldname">
vchrdy</td>
<td class="fielddoc">
Charge Ready (VCHRDY) voltage threshold (mV) <p >Minimum voltage accepted on the storage element before starting to supply LOAD (mV) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="acacdb0e13a96725aa03467e00b288ea8" name="acacdb0e13a96725aa03467e00b288ea8"></a>uint32_t</td>
<td class="fieldname">
vovch</td>
<td class="fielddoc">
Overcharge (VOVCH) threshold. <p >Maximum voltage accepted on the storage element before disabling is charging (mV) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a087b4fc3674693b42a9068dc93c40046" name="a087b4fc3674693b42a9068dc93c40046"></a>bool</td>
<td class="fieldname">
vovdis_irq_enable</td>
<td class="fielddoc">
Enable/Disable the IRQ pin to be asserted (HIGH) when the storage level crosses the overdischarge threshold. <p >Set to <code>true</code> to enable, to <code>false</code> to disable </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aa5a1671572fd774c122b6925c675b107" name="aa5a1671572fd774c122b6925c675b107"></a>bool</td>
<td class="fieldname">
vchrdy_irq_enable</td>
<td class="fielddoc">
Enable/Disable the IRQ pin to be asserted (HIGH) when the storage level crosses the charge ready threshold. <p >Set to <code>true</code> to enable, to <code>false</code> to disable </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a11d38ab963ec389097aa966fb1ee89ce" name="a11d38ab963ec389097aa966fb1ee89ce"></a>bool</td>
<td class="fieldname">
vovch_irq_enable</td>
<td class="fielddoc">
Enable/Disable the IRQ pin to be asserted (HIGH) when the storage level crosses the overcharge threshold. <p >Set to <code>true</code> to enable, to <code>false</code> to disable </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a46a412438c8371dbf97c5cafd860a3b0" name="a46a412438c8371dbf97c5cafd860a3b0"></a>bool</td>
<td class="fieldname">
sto_done_irq_enable</td>
<td class="fielddoc">
Enable/Disable the IRQ pin to be asserted (HIGH) when a new data from the STO ADC is available. <p >Set to <code>true</code> to enable, to <code>false</code> to disable </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aa3ad65a12a699fb3def373e15aeb06ef" name="aa3ad65a12a699fb3def373e15aeb06ef"></a>bool</td>
<td class="fieldname">
temp_mon_enable</td>
<td class="fielddoc">
Enable/Disable the ambient Temperature Monitoring. <p >Set to <code>true</code> to enable, to <code>false</code> to disable </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aa6413071a775025b046061afc50b5bd7" name="aa6413071a775025b046061afc50b5bd7"></a>bool</td>
<td class="fieldname">
temp_ch_irq_enable</td>
<td class="fielddoc">
Enable/Disable the IRQ pin to be asserted (HIGH) when the ambient temperature is out of the defined range for storage element charging. <p >Set to <code>true</code> to enable, to <code>false</code> to disable </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a48edd62dca9889ad4a8467c46f7d447f" name="a48edd62dca9889ad4a8467c46f7d447f"></a>bool</td>
<td class="fieldname">
temp_dis_irq_enable</td>
<td class="fielddoc">
Enable/Disable the IRQ pin to be asserted (HIGH) when the ambient temperature is out of the defined range for storage element discharging. <p >Set to <code>true</code> to enable, to <code>false</code> to disable </p>
</td></tr>
<tr><td class="fieldtype">
<a id="abd0553b9bd10787c3de831c28b4544df" name="abd0553b9bd10787c3de831c28b4544df"></a>bool</td>
<td class="fieldname">
temp_done_irq_enable</td>
<td class="fielddoc">
Enable/Disable the IRQ pin to be asserted (HIGH) when a new data from the temperature ADC is available. <p >Set to <code>true</code> to enable, to <code>false</code> to disable </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a4ce2c559c34d969b096ef14278754b9e" name="a4ce2c559c34d969b096ef14278754b9e"></a>uint32_t</td>
<td class="fieldname">
temp_rdiv</td>
<td class="fielddoc">
Impedance of the resistor Rdiv, that creates a resistive voltage divider together with the thermistor Rth (mOhms) <dl class="section note"><dt>Note</dt><dd>This setting is only required when using the Temperature Monitoring feature. </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a id="a297f3ee8dbf211099d61c2e9b1cff8c3" name="a297f3ee8dbf211099d61c2e9b1cff8c3"></a>uint32_t</td>
<td class="fieldname">
temp_cold_ch_rth</td>
<td class="fielddoc">
Impedance of the thermistor (Rth) at the 'cold' threshold (mOhms) for storage element charging. <dl class="section note"><dt>Note</dt><dd>This setting is only required when using the Temperature Monitoring feature. </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a id="a7a94f0d4fb86baafa2e7e3188c0b01ec" name="a7a94f0d4fb86baafa2e7e3188c0b01ec"></a>uint32_t</td>
<td class="fieldname">
temp_hot_ch_rth</td>
<td class="fielddoc">
Impedance of the thermistor (Rth) at the 'hot' threshold (mOhms) for storage element charging. <dl class="section note"><dt>Note</dt><dd>This setting is only required when using the Temperature Monitoring feature. </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a id="a6062d08f7cbd02a9e4851004d837fabb" name="a6062d08f7cbd02a9e4851004d837fabb"></a>uint32_t</td>
<td class="fieldname">
temp_cold_dis_rth</td>
<td class="fielddoc">
Impedance of the thermistor (Rth) at the 'cold' threshold (mOhms) for storage element discharging. <dl class="section note"><dt>Note</dt><dd>This setting is only required when using the Temperature Monitoring feature. </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a id="a707ab29617bf821c742474899afde0a8" name="a707ab29617bf821c742474899afde0a8"></a>uint32_t</td>
<td class="fieldname">
temp_hot_dis_rth</td>
<td class="fielddoc">
Impedance of the thermistor (Rth) at the 'hot' threshold (mOhms) for storage element discharging. <dl class="section note"><dt>Note</dt><dd>This setting is only required when using the Temperature Monitoring feature. </dd></dl>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga9eb083a7b35a8682dde64fa11a14055f" name="ga9eb083a7b35a8682dde64fa11a14055f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9eb083a7b35a8682dde64fa11a14055f">&#9670;&nbsp;</a></span>AEM13920_Initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_Initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the driver. </p>
<p >Initialize the communication interface and retrieve the IC version</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
The AEM is out of its reset sequence (see the datasheet, "Configuration by I2C") </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The communication interface is initialized, and the driver's functions can be used </dd>
<dd>
<code>handler-&gt;version</code> is set with the version of the chip </dd></dl>

</div>
</div>
<a id="gaacf528a2600a42d317f0a898064cea50" name="gaacf528a2600a42d317f0a898064cea50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacf528a2600a42d317f0a898064cea50">&#9670;&nbsp;</a></span>AEM13920_Deinitialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_Deinitialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deinitialize the driver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Any resources allocated to the communication interface are released. Any call to the driver's functions will fail until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga9eb083a7b35a8682dde64fa11a14055f" title="Initialize the driver.">AEM13920_Initialize()</a> function is called </dd></dl>

</div>
</div>
<a id="gab6b7fcbcc3aad9e0003b85ede536db92" name="gab6b7fcbcc3aad9e0003b85ede536db92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6b7fcbcc3aad9e0003b85ede536db92">&#9670;&nbsp;</a></span>AEM13920_GetSourceRegulationMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetSourceRegulationMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#gacb18d945a027bcda7a2f30ea0103f2b5">AEM13920_SRCREGU_MODE</a> *&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the SRCx regulation mode. </p>
<p >This function reads the SRCxREGU0 register and sets <code>mode</code> accordingly, where <code>x</code> is the selected source</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Source </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mode</td><td>Source regulation mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>mode</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>mode</code> is set with the source regulation mode </dd></dl>

</div>
</div>
<a id="ga2118409faadb17ffe64726f644e208db" name="ga2118409faadb17ffe64726f644e208db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2118409faadb17ffe64726f644e208db">&#9670;&nbsp;</a></span>AEM13920_SetSourceRegulationMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_SetSourceRegulationMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#gacb18d945a027bcda7a2f30ea0103f2b5">AEM13920_SRCREGU_MODE</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set SRCx' regulation mode. </p>
<p >This function writes the SRCxREGU0 register to match the mode defined in <code>mode</code>, where <code>x</code> is the selected source</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Source to configure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Source regulation mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The source regulation mode is set according to <code>mode</code> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="gade23493c7e53c0222555e3eaf405049c" name="gade23493c7e53c0222555e3eaf405049c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade23493c7e53c0222555e3eaf405049c">&#9670;&nbsp;</a></span>AEM13920_GetSourceRegulationVoltage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetSourceRegulationVoltage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>srcregu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the voltage at which the SRCx is regulated. </p>
<p >If SRCx' regulation mode is set to constant voltage, this function reads the SRCxREGU0 and SRCxREGU1 registers, where <code>x</code> is the selected source, and sets <code>srcregu</code> accordingly. Otherwise, it reads the SRCx register and sets <code>srcregu</code> accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Source </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">srcregu</td><td>Regulation Voltage (mV) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>srcregu</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If SRCx' regulation mode is set to constant voltage, <code>srcregu</code> is set with the configured source regulation voltage. Otherwise, it is set with the voltage at which the source is actually regulated via the MPPT. </dd></dl>

</div>
</div>
<a id="ga35f829385956d74821d427b27c50843d" name="ga35f829385956d74821d427b27c50843d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35f829385956d74821d427b27c50843d">&#9670;&nbsp;</a></span>AEM13920_SetSourceConstantVoltage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_SetSourceConstantVoltage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcregu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set SRCx's regulation to a constant voltage. </p>
<p >This function writes the SRCxREGU0 and SRCxREGU1 registers, where <code>x</code> is the selected source. It sets the source regulation mode to constant voltage and configures the regulation voltage according to <code>srcregu</code>. The source regulation voltage is set to the closest authorized value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Source to configure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcregu</td><td>Regulation Voltage (mV) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The source regulation voltage is set according to <code>srcregu</code> </dd>
<dd>
The source regulation mode is set to constant voltage </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd>
<dd>
Calling this function sets the source regulation mode to constant voltage, no matter what the previous mode was. </dd></dl>

</div>
</div>
<a id="ga854fbe1ed90df7646dff8d16c0c4348f" name="ga854fbe1ed90df7646dff8d16c0c4348f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga854fbe1ed90df7646dff8d16c0c4348f">&#9670;&nbsp;</a></span>AEM13920_GetMPPTConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetMPPTConfig </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#struct_a_e_m13920___m_p_p_t_c_f_g__t">AEM13920_MPPTCFG_t</a> *&#160;</td>
          <td class="paramname"><em>cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the MPPT configuration for SRCx (ratio, period, and duration) </p>
<p >This function reads the SRCxREGU0 and SRCxREGU1 registers and sets <code>cfg</code> accordingly, where <code>x</code> is the selected source</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Source </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cfg</td><td>MPPT configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>cfg</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If the SRCx regulation mode is set to MPPT, <code>cfg</code> is set with the MPPT configuration of SRCx. Otherwise, <code>cfg</code> remains unchanged. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><code>cfg</code> is only valid when the source regulation mode is set to MPPT. </dd></dl>

</div>
</div>
<a id="ga15fde65c5cf6d997fdfefdd3d7c4ac90" name="ga15fde65c5cf6d997fdfefdd3d7c4ac90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15fde65c5cf6d997fdfefdd3d7c4ac90">&#9670;&nbsp;</a></span>AEM13920_SetMPPTConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_SetMPPTConfig </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___a_e_m13920___common.html#struct_a_e_m13920___m_p_p_t_c_f_g__t">AEM13920_MPPTCFG_t</a> *&#160;</td>
          <td class="paramname"><em>cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the MPPT configuration for SRCx (ratio, period, and duration) </p>
<p >This function writes the SRCxREGU0 and SRCxREGU1 registers, where <code>x</code> is the selected source, It sets the source regulation mode to MPPT and configures the MPPT according to <code>cfg</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Source to configure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cfg</td><td>MPPT configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>cfg</code> is correctly initialized </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The MPPT configuration is set according to <code>cfg</code> </dd>
<dd>
The source regulation mode is set to MPPT </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd>
<dd>
Calling this function sets the source regulation mode to MPPT, no matter what the previous mode was. </dd></dl>

</div>
</div>
<a id="ga750a459aa627a44c0ed10ea176270320" name="ga750a459aa627a44c0ed10ea176270320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga750a459aa627a44c0ed10ea176270320">&#9670;&nbsp;</a></span>AEM13920_GetMPPTRatio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetMPPTRatio </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga7d6badc834d624377918cb765257eb21">AEM13920_MPPT_RATIO</a> *&#160;</td>
          <td class="paramname"><em>ratio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the configured MPPT ratio for SRCx. </p>
<p >This function reads the CFG0 field of the SRCxREGU0 register and sets <code>ratio</code> accordingly, where <code>x</code> is the selected source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Source </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ratio</td><td>MPPT ratio </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>ratio</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If the SRCx regulation mode is set to MPPT, <code>ratio</code> is set with the configured MPPT ratio. Otherwise, <code>ratio</code> remains unchanged. </dd></dl>

</div>
</div>
<a id="gab0c5027a9cfc427091613914607accd1" name="gab0c5027a9cfc427091613914607accd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0c5027a9cfc427091613914607accd1">&#9670;&nbsp;</a></span>AEM13920_SetMPPTRatio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_SetMPPTRatio </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga7d6badc834d624377918cb765257eb21">AEM13920_MPPT_RATIO</a>&#160;</td>
          <td class="paramname"><em>ratio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the MPPT ratio for SRCx. </p>
<p >This function writes CFG0 field of the SRCxREGU0 register to match the ratio set in <code>ratio</code>, where <code>x</code> is the selected source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Source to configure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ratio</td><td>MPPT ratio </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The MPPT ratio is set according to <code>ratio</code> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd>
<dd>
This function should only be used if the source regulation mode has been previously set to MPPT via a call to the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga2118409faadb17ffe64726f644e208db" title="Set SRCx&#39; regulation mode.">AEM13920_SetSourceRegulationMode()</a> function. Otherwise, it would overwrite the constant voltage configuration, leading to unpredictable behavior. </dd></dl>

</div>
</div>
<a id="ga8522aa225c7ec9101653ad81e17d5797" name="ga8522aa225c7ec9101653ad81e17d5797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8522aa225c7ec9101653ad81e17d5797">&#9670;&nbsp;</a></span>AEM13920_GetMPPTDuration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetMPPTDuration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#gaa2752ec46c5474b8438482c31f542bd9">AEM13920_MPPT_DURATION</a> *&#160;</td>
          <td class="paramname"><em>duration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the configured MPPT duration for SRCx. </p>
<p >This function reads the CFG1 field of the SRCxREGU0 register and sets <code>duration</code> accordingly, where <code>x</code> is the selected source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Source </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">duration</td><td>MPPT duration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>duration</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If the SRCx regulation mode is set to MPPT, <code>duration</code> is set with the configured MPPT duration. Otherwise, <code>ratio</code> remains unchanged. </dd></dl>

</div>
</div>
<a id="ga21adc4e2b75e726fde224af614c62d8d" name="ga21adc4e2b75e726fde224af614c62d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21adc4e2b75e726fde224af614c62d8d">&#9670;&nbsp;</a></span>AEM13920_SetMPPTDuration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_SetMPPTDuration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#gaa2752ec46c5474b8438482c31f542bd9">AEM13920_MPPT_DURATION</a>&#160;</td>
          <td class="paramname"><em>duration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the MPPT duration for SRCx. </p>
<p >This function writes the CFG1 field of the SRCxREGU1 register to match the duration set in <code>duration</code>, where <code>x</code> is the selected source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Source to configure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">duration</td><td>MPPT duration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The MPPT duration is set according to <code>duration</code> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd>
<dd>
This function should only be used if the source regulation mode has been previously set to MPPT via a call to the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga2118409faadb17ffe64726f644e208db" title="Set SRCx&#39; regulation mode.">AEM13920_SetSourceRegulationMode()</a> function. Otherwise, it would overwrite the constant voltage configuration, leading to unpredictable behavior. </dd></dl>

</div>
</div>
<a id="ga72a64dc0b3953c53d9c82cc43af69469" name="ga72a64dc0b3953c53d9c82cc43af69469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72a64dc0b3953c53d9c82cc43af69469">&#9670;&nbsp;</a></span>AEM13920_GetMPPTPeriod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetMPPTPeriod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga74be84c7513ff30f51bedfe7c254c0be">AEM13920_MPPT_PERIOD</a> *&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the configured MPPT period for SRCx. </p>
<p >This function reads the CFG2 field of the SRCxREGU1 register and sets <code>period</code> accordingly, where <code>x</code> is the selected source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Source </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">period</td><td>MPPT period </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>period</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If the SRCx regulation mode is set to MPPT, <code>period</code> is set with the configured MPPT period. Otherwise, <code>period</code> remains unchanged. </dd></dl>

</div>
</div>
<a id="gac3585b2b342431573cd0b2c04342696d" name="gac3585b2b342431573cd0b2c04342696d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3585b2b342431573cd0b2c04342696d">&#9670;&nbsp;</a></span>AEM13920_SetMPPTPeriod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_SetMPPTPeriod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga74be84c7513ff30f51bedfe7c254c0be">AEM13920_MPPT_PERIOD</a>&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the MPPT period for SRCx. </p>
<p >This function writes the CFG2 field of the SRCxREGU1 register to match the period set in <code>period</code>, where <code>x</code> is the selected source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Source to configure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">period</td><td>MPPT period </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The MPPT period is set according to <code>period</code> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd>
<dd>
This function should only be used if the source regulation mode has been previously set to MPPT via a call to the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga2118409faadb17ffe64726f644e208db" title="Set SRCx&#39; regulation mode.">AEM13920_SetSourceRegulationMode()</a> function. Otherwise, it would overwrite the constant voltage configuration, leading to unpredictable behavior. </dd></dl>

</div>
</div>
<a id="ga9a7e3cf39bd40165686f06cc2baeab0c" name="ga9a7e3cf39bd40165686f06cc2baeab0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a7e3cf39bd40165686f06cc2baeab0c">&#9670;&nbsp;</a></span>AEM13920_GetOverdischargeVoltage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetOverdischargeVoltage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>vovdis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the configured VOVDIS threshold (mV) </p>
<p >This function reads the VOVDIS register and sets <code>vovdis</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vovdis</td><td>Configured overdischarge voltage threshold (mV) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>vovdis</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>vovdis</code> is set according to the configured 'overdischarge' voltage threshold </dd></dl>

</div>
</div>
<a id="ga977e09029a4df85e82f3667d8cb4285f" name="ga977e09029a4df85e82f3667d8cb4285f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga977e09029a4df85e82f3667d8cb4285f">&#9670;&nbsp;</a></span>AEM13920_SetOverdischargeVoltage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_SetOverdischargeVoltage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>vovdis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the VOVDIS threshold (mV) </p>
<p >This function writes the VOVDIS register to match the voltage defined in <code>vovdis</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vovdis</td><td>Overdischarge voltage threshold (mV) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The overdischarge threshold is set according to <code>vovdis</code> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <code>vovdis</code> is under 2.4V, the effective threshold is set to 2.4V. If <code>vovdis</code> is above 3.581V, the effective threshold is set to 3.581V. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="ga57b290f75eddd13dff9482ae21065313" name="ga57b290f75eddd13dff9482ae21065313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57b290f75eddd13dff9482ae21065313">&#9670;&nbsp;</a></span>AEM13920_GetChargeReadyVoltage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetChargeReadyVoltage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>vchrdy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the configured VCHRDY threshold (mV) </p>
<p >This function reads the VCHRDY register and sets <code>vchrdy</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vchrdy</td><td>Configured charge ready voltage threshold (mV) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>vchrdy</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>vchrdy</code> is set according to the configured 'charge ready' voltage threshold </dd></dl>

</div>
</div>
<a id="ga16f4672905b61b364903b655b93d0eb1" name="ga16f4672905b61b364903b655b93d0eb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16f4672905b61b364903b655b93d0eb1">&#9670;&nbsp;</a></span>AEM13920_SetChargeReadyVoltage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_SetChargeReadyVoltage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>vchrdy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the VCHRDY threshold (mV) </p>
<p >This function writes the VCHRDY register to match the voltage defined in <code>vchrdy</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vchrdy</td><td>Charge ready voltage threshold (mV) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The charge ready threshold is set according to <code>vchrdy</code> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <code>vchrdy</code> is under 2.456V, the effective threshold is set to 2.456V. If <code>vchrdy</code> is above 3.637V, the effective threshold is set to 3.637V. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="gaf7089449a795c3e7ebbf9242e364fbc8" name="gaf7089449a795c3e7ebbf9242e364fbc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7089449a795c3e7ebbf9242e364fbc8">&#9670;&nbsp;</a></span>AEM13920_GetOverchargeVoltage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetOverchargeVoltage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>vovch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the configured VOVCH threshold (mV) </p>
<p >This function reads the VOVCH register and sets <code>vovch</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vovch</td><td>Configured overcharge voltage threshold (mV) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>vovch</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>vovch</code> is set according to the configured 'overcharge' voltage threshold </dd></dl>

</div>
</div>
<a id="gafa0c702028228b0f80bd5d834970ee68" name="gafa0c702028228b0f80bd5d834970ee68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa0c702028228b0f80bd5d834970ee68">&#9670;&nbsp;</a></span>AEM13920_SetOverchargeVoltage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_SetOverchargeVoltage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>vovch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the VOVCH threshold (mV) </p>
<p >This function writes the VOVCH register to match the voltage defined in <code>vovch</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c_cfg</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vovch</td><td>Overcharge voltage threshold (mV) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The overcharge threshold is set according to <code>vovch</code> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <code>vovch</code> is under 2.7V, the effective threshold is set to 2.7V. If <code>vovch</code> is above 4.594V, the effective threshold is set to 4.594V. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="ga21012b694a6aec710e3f7a468444cc52" name="ga21012b694a6aec710e3f7a468444cc52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21012b694a6aec710e3f7a468444cc52">&#9670;&nbsp;</a></span>AEM13920_GetBoostConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetBoostConfig </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#struct_a_e_m13920___b_s_t_c_f_g__t">AEM13920_BSTCFG_t</a> *&#160;</td>
          <td class="paramname"><em>cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the boost configuration for SRCx. </p>
<p >This function reads the BSTxCFG and sets <code>cfg</code> accordingly, where <code>x</code> is the selected source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Source </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cfg</td><td>Boost configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>cfg</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>cfg</code> is set with the boost configuration </dd></dl>

</div>
</div>
<a id="ga8bd4acfc22ee294d3199c784831443a5" name="ga8bd4acfc22ee294d3199c784831443a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bd4acfc22ee294d3199c784831443a5">&#9670;&nbsp;</a></span>AEM13920_SetBoostConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_SetBoostConfig </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___a_e_m13920___common.html#struct_a_e_m13920___b_s_t_c_f_g__t">AEM13920_BSTCFG_t</a> *&#160;</td>
          <td class="paramname"><em>cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the boost configuration for SRCx. </p>
<p >This function writes the BSTxCFG register to match the configuration defined in <code>cfg</code>, where <code>x</code> is the selected source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Source to configure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cfg</td><td>Boost configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>cfg</code> is correctly initialized </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The boost configuration is set according to <code>cfg</code> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="gab598380ff2f0268dae11a068f8b22394" name="gab598380ff2f0268dae11a068f8b22394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab598380ff2f0268dae11a068f8b22394">&#9670;&nbsp;</a></span>AEM13920_EnableBoost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_EnableBoost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a>&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the boost converter for SRCx. </p>
<p >This function sets the EN field of the BSTxCFG register, where <code>x</code> is the selected source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Source </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>SRCx' boost converter is enabled </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="gab683fa2d584c043f435f826165281626" name="gab683fa2d584c043f435f826165281626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab683fa2d584c043f435f826165281626">&#9670;&nbsp;</a></span>AEM13920_DisableBoost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_DisableBoost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a>&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the boost converter for SRCx. </p>
<p >This function clears the EN field of the BSTxCFG register, where <code>x</code> is the selected source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Source </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>SRCx' boost converter is disabled </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="ga970fa2bb5bfb54eb0690084ed9c3c201" name="ga970fa2bb5bfb54eb0690084ed9c3c201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga970fa2bb5bfb54eb0690084ed9c3c201">&#9670;&nbsp;</a></span>AEM13920_IsEnabledBoost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_IsEnabledBoost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>en</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the enabling status of the boost converter for SRCx. </p>
<p >This function reads the EN field of the BSTxCFG register, where <code>x</code> is the selected source, and sets <code>en</code> accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Source </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">en</td><td>Boost converter's enabling status </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>en</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>en</code> is set with the enabling status of SRCx' boost converter </dd></dl>

</div>
</div>
<a id="ga5ea7942ee4ff16cb4f5cc433eed1a150" name="ga5ea7942ee4ff16cb4f5cc433eed1a150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ea7942ee4ff16cb4f5cc433eed1a150">&#9670;&nbsp;</a></span>AEM13920_EnableHighPower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_EnableHighPower </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a>&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the high power mode for SRCx. </p>
<p >This function sets the HPEN field of the BSTxCFG register, where <code>x</code> is the selected source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Source </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>SRCx' high power mode is enabled </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="gab531d584f77f693de01d1cb95620edea" name="gab531d584f77f693de01d1cb95620edea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab531d584f77f693de01d1cb95620edea">&#9670;&nbsp;</a></span>AEM13920_DisableHighPower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_DisableHighPower </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a>&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Diable the high power mode for SRCx. </p>
<p >This function clears the HPEN field of the BSTxCFG register, where <code>x</code> is the selected source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Source </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>SRCx' high power mode is disabled </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="ga33628925f8b797baf5e856c24483b502" name="ga33628925f8b797baf5e856c24483b502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33628925f8b797baf5e856c24483b502">&#9670;&nbsp;</a></span>AEM13920_IsEnabledHighPower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_IsEnabledHighPower </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>en</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the enabling status of the high power mode for SRCx. </p>
<p >This function reads the HPEN field of the BSTxCFG register, where <code>x</code> is the selected source, and sets <code>en</code> accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Source </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">en</td><td>High power mode's enabling status </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>en</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>en</code> is set with the enabling status of SRCx' high power mode </dd></dl>

</div>
</div>
<a id="gacb4f46e9f099e435be92337a24b150b3" name="gacb4f46e9f099e435be92337a24b150b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb4f46e9f099e435be92337a24b150b3">&#9670;&nbsp;</a></span>AEM13920_SetBoostTimingMultiplier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_SetBoostTimingMultiplier </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#gaf5a0206be099bb00343f8142ed830d8c">AEM13920_TMULT</a>&#160;</td>
          <td class="paramname"><em>tmult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the boost converter's timing multiplier for SRCx. </p>
<p >This function writes the TMULT field of the BSTxCFG register, where <code>x</code> is the selected source, to match the value defined in <code>tmult</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Source to configure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmult</td><td>Timing multiplier </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The timing multiplier is set according to <code>tmult</code> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="ga14a338660e28bf9df0c952f837064bac" name="ga14a338660e28bf9df0c952f837064bac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14a338660e28bf9df0c952f837064bac">&#9670;&nbsp;</a></span>AEM13920_GetBoostTimingMultiplier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetBoostTimingMultiplier </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#gaf5a0206be099bb00343f8142ed830d8c">AEM13920_TMULT</a> *&#160;</td>
          <td class="paramname"><em>tmult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the configured boost converter's timing multiplier for SRCx. </p>
<p >This function reads the TMULT field of the BSTxCFG register, where <code>x</code> is the selected source, and sets <code>tmult</code> accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Source </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tmult</td><td>Boost converter's timing multiplier </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>tmult</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>tmult</code> is set with the configured timing multiplier </dd></dl>

</div>
</div>
<a id="ga70d97b1bdadc7dfae2d08c40a5924665" name="ga70d97b1bdadc7dfae2d08c40a5924665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70d97b1bdadc7dfae2d08c40a5924665">&#9670;&nbsp;</a></span>AEM13920_SetBuckConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_SetBuckConfig </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___a_e_m13920___common.html#struct_a_e_m13920___b_u_c_k_c_f_g__t">AEM13920_BUCKCFG_t</a> *&#160;</td>
          <td class="paramname"><em>cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the buck converter's configuration. </p>
<p >This function writes the BUCKCFG register to match the configuration defined in <code>cfg</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cfg</td><td>Buck configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>cfg</code> is correctly initialized </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The buck configuration is set according to <code>cfg</code> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="gafc9b2d744e77f8d8cfa3d0e7f27d7c4c" name="gafc9b2d744e77f8d8cfa3d0e7f27d7c4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc9b2d744e77f8d8cfa3d0e7f27d7c4c">&#9670;&nbsp;</a></span>AEM13920_GetBuckConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetBuckConfig </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#struct_a_e_m13920___b_u_c_k_c_f_g__t">AEM13920_BUCKCFG_t</a> *&#160;</td>
          <td class="paramname"><em>cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the buck converter's configuration. </p>
<p >This function reads the BUCKCFG register and sets <code>cfg</code> accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cfg</td><td>Buck configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>cfg</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>cfg</code> is set with the buck configuration </dd></dl>

</div>
</div>
<a id="gab5ba4480084340f1b25416b55db8a863" name="gab5ba4480084340f1b25416b55db8a863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5ba4480084340f1b25416b55db8a863">&#9670;&nbsp;</a></span>AEM13920_SetBuckVOUT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_SetBuckVOUT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#gabd96065f60e993d0a866343dfcacb1fb">AEM13920_VOUT</a>&#160;</td>
          <td class="paramname"><em>vout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the buck converter's output regulation voltage. </p>
<p >This function writes the VOUT field of the BUCKCFG register to match the voltage defined in <code>vout</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vout</td><td>Buck output voltage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The buck output voltage is set according to <code>vout</code> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="ga00cba59af52811b1b802fd3007f90716" name="ga00cba59af52811b1b802fd3007f90716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00cba59af52811b1b802fd3007f90716">&#9670;&nbsp;</a></span>AEM13920_GetBuckVOUT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetBuckVOUT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#gabd96065f60e993d0a866343dfcacb1fb">AEM13920_VOUT</a> *&#160;</td>
          <td class="paramname"><em>vout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the buck converter's output regulation voltage. </p>
<p >This function reads the VOUT field of the BUCKCFG register and sets <code>vout</code> accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vout</td><td>Buck output voltage (mV) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>vout</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>vout</code> is set with the buck output voltage </dd></dl>

</div>
</div>
<a id="ga11e0b18de78293de56f7a65ccbdf1c68" name="ga11e0b18de78293de56f7a65ccbdf1c68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11e0b18de78293de56f7a65ccbdf1c68">&#9670;&nbsp;</a></span>AEM13920_SetBuckTimingMultiplier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_SetBuckTimingMultiplier </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#gaf5a0206be099bb00343f8142ed830d8c">AEM13920_TMULT</a>&#160;</td>
          <td class="paramname"><em>tmult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the buck converter's timing multiplier. </p>
<p >This function writes the TMULT field of the BUCKCFG register to match the value defined in <code>tmult</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmult</td><td>Timing multiplier </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The timing multiplier is set according to <code>tmult</code> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="ga4f5b017dd4ca89ab52a2138fc56de87f" name="ga4f5b017dd4ca89ab52a2138fc56de87f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f5b017dd4ca89ab52a2138fc56de87f">&#9670;&nbsp;</a></span>AEM13920_GetBuckTimingMultiplier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetBuckTimingMultiplier </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#gaf5a0206be099bb00343f8142ed830d8c">AEM13920_TMULT</a> *&#160;</td>
          <td class="paramname"><em>tmult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the buck converter's configured timing multiplier. </p>
<p >This function reads the TMULT field of the BUCKCFG register and sets <code>tmult</code> accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tmult</td><td>Buck converter's timing multiplier </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>tmult</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>tmult</code> is set with the buck converter's timing multiplier </dd></dl>

</div>
</div>
<a id="ga03f3fc61d5874ab46f802701663010a2" name="ga03f3fc61d5874ab46f802701663010a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03f3fc61d5874ab46f802701663010a2">&#9670;&nbsp;</a></span>AEM13920_GetTempColdChargeThresh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetTempColdChargeThresh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>rth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rdiv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the configured thermistor impedance (RTH) at the minimum accepted temperature for charging the storage element. </p>
<p >This function reads the TEMPCOLDCH register and sets <code>rth</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rth</td><td>Configured thermistor's impedance (Rth) at the 'cold' temperature threshold for charging (mOhms) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rdiv</td><td>Impedance of the resistor that creates a resistive voltage divider with Rth (mOhms) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>rth</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>rth</code> is set according to the configured 'cold' temperature threshold for charging </dd></dl>

</div>
</div>
<a id="ga27d9f7a8c644d0a90ce1f5ee00c144ab" name="ga27d9f7a8c644d0a90ce1f5ee00c144ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27d9f7a8c644d0a90ce1f5ee00c144ab">&#9670;&nbsp;</a></span>AEM13920_SetTempColdChargeThresh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_SetTempColdChargeThresh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rdiv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the thermistor impedance (RTH) at the minimum accepted temperature for charging the storage element. </p>
<p >This function writes the TEMPCOLDCH register to match the impedance defined in <code>rth</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rth</td><td>Thermistor's impedance (Rth) at the 'cold' temperature threshold for charging (mOhms) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rdiv</td><td>Impedance of the resistor that creates a resistive voltage divider with Rth (mOhms) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The 'cold' temperature threshold for charging is set according to <code>rth</code> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the temperature monitoring feature is not enabled, the configured threshold has no effect </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga41df19aaf0d3ffad0f964b98b93f465c" title="Enable the monitoring of the ambient temperature.">AEM13920_EnableTempMon()</a> </dd></dl>

</div>
</div>
<a id="ga5147ef4bca0b7f20ebf3e86deaf127c9" name="ga5147ef4bca0b7f20ebf3e86deaf127c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5147ef4bca0b7f20ebf3e86deaf127c9">&#9670;&nbsp;</a></span>AEM13920_GetTempHotChargeThresh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetTempHotChargeThresh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>rth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rdiv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the configured thermistor impedance at the maximum temperature for storage element charging. </p>
<p >This function reads the TEMPHOTCH register and sets <code>rth</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rth</td><td>Configured thermistor's impedance (Rth) at the 'hot' temperature threshold for charging (mOhms) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rdiv</td><td>Impedance of the resistor that creates a resistive voltage divider with Rth (mOhms) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>rth</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>rth</code> is set according to the configured 'hot' temperature threshold for charging </dd></dl>

</div>
</div>
<a id="ga5dfc40610c7c28912c72b4933eaf2cf4" name="ga5dfc40610c7c28912c72b4933eaf2cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5dfc40610c7c28912c72b4933eaf2cf4">&#9670;&nbsp;</a></span>AEM13920_SetTempHotChargeThresh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_SetTempHotChargeThresh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rdiv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the thermistor impedance at the maximum temperature for storage element charging. </p>
<p >This function writes the TEMPHOTCH register to match the impedance defined in <code>rth</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rth</td><td>Thermistor's impedance (Rth) at the 'hot' temperature threshold for charging (mOhms) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rdiv</td><td>Impedance of the resistor that creates a resistive voltage divider with Rth (mOhms) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The 'hot' temperature threshold for charging is set according to <code>rth</code> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the temperature monitoring feature is not enabled, the configured threshold has no effect </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga41df19aaf0d3ffad0f964b98b93f465c" title="Enable the monitoring of the ambient temperature.">AEM13920_EnableTempMon()</a> </dd></dl>

</div>
</div>
<a id="ga5f5103e0a598e46bae7fc585dd5b19b4" name="ga5f5103e0a598e46bae7fc585dd5b19b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f5103e0a598e46bae7fc585dd5b19b4">&#9670;&nbsp;</a></span>AEM13920_GetTempColdDischargeThresh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetTempColdDischargeThresh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>rth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rdiv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the configured thermistor impedance at the minimum temperature for storage element discharging. </p>
<p >This function reads the TEMPCOLDDIS register and sets <code>rth</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rth</td><td>Configured thermistor's impedance (Rth) at the 'cold' temperature threshold for discharging (mOhms) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rdiv</td><td>Impedance of the resistor that creates a resistive voltage divider with Rth (mOhms) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>rth</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>rth</code> is set according to the configured 'cold' temperature threshold for discharging </dd></dl>

</div>
</div>
<a id="ga1a9bef8360211bfb3d61ec9a9dfcd714" name="ga1a9bef8360211bfb3d61ec9a9dfcd714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a9bef8360211bfb3d61ec9a9dfcd714">&#9670;&nbsp;</a></span>AEM13920_SetTempColdDischargeThresh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_SetTempColdDischargeThresh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rdiv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the thermistor impedance at the minimum temperature for storage element discharging. </p>
<p >This function writes the TEMPCOLDDIS register to match the impedance defined in <code>rth</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rth</td><td>Thermistor's impedance (Rth) at the 'cold' temperature threshold for discharging (mOhms) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rdiv</td><td>Impedance of the resistor that creates a resistive voltage divider with Rth (mOhms) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The 'cold' temperature threshold for discharging is set according to <code>rth</code> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the temperature monitoring feature is not enabled, the configured threshold has no effect </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga41df19aaf0d3ffad0f964b98b93f465c" title="Enable the monitoring of the ambient temperature.">AEM13920_EnableTempMon()</a> </dd></dl>

</div>
</div>
<a id="ga19baa44b9e7dacacd13416ddcc8055e6" name="ga19baa44b9e7dacacd13416ddcc8055e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19baa44b9e7dacacd13416ddcc8055e6">&#9670;&nbsp;</a></span>AEM13920_GetTempHotDischargeThresh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetTempHotDischargeThresh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>rth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rdiv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the configured thermistor impedance at the maximum temperature for storage element discharging. </p>
<p >This function reads the TEMPHOTDIS register and sets <code>rth</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rth</td><td>Configured thermistor's impedance (Rth) at the 'hot' temperature threshold for discharging (mOhms) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rdiv</td><td>Impedance of the resistor that creates a resistive voltage divider with Rth (mOhms) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>rth</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>rth</code> is set according to the configured 'hot' temperature threshold for discharging </dd></dl>

</div>
</div>
<a id="ga3e7dd874220c8465591d277ec30c4ada" name="ga3e7dd874220c8465591d277ec30c4ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e7dd874220c8465591d277ec30c4ada">&#9670;&nbsp;</a></span>AEM13920_SetTempHotDischargeThresh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_SetTempHotDischargeThresh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rdiv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the thermistor impedance at the maximum temperature for storage element discharging. </p>
<p >This function writes the TEMPHOTDIS register to match the impedance defined in <code>rth</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rth</td><td>Thermistor's impedance (Rth) at the 'hot' temperature threshold for discharging (mOhms) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rdiv</td><td>Impedance of the resistor that creates a resistive voltage divider with Rth (mOhms) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The 'hot' temperature threshold for discharging is set according to <code>rth</code> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the temperature monitoring feature is not enabled, the configured threshold has no effect </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga41df19aaf0d3ffad0f964b98b93f465c" title="Enable the monitoring of the ambient temperature.">AEM13920_EnableTempMon()</a> </dd></dl>

</div>
</div>
<a id="ga41df19aaf0d3ffad0f964b98b93f465c" name="ga41df19aaf0d3ffad0f964b98b93f465c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41df19aaf0d3ffad0f964b98b93f465c">&#9670;&nbsp;</a></span>AEM13920_EnableTempMon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_EnableTempMon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the monitoring of the ambient temperature. </p>
<p >This function sets the EN field of the TMON register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The monitoring of the ambient temperature is enabled </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="ga34f1dde7c33bfbe8abb355959f76edde" name="ga34f1dde7c33bfbe8abb355959f76edde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34f1dde7c33bfbe8abb355959f76edde">&#9670;&nbsp;</a></span>AEM13920_DisableTempMon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_DisableTempMon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the monitoring of the ambient temperature. </p>
<p >This function clears the EN field of the TMON register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The monitoring of the ambient temperature is disabled </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="ga339540468510d05e8c4067666fb2d6ea" name="ga339540468510d05e8c4067666fb2d6ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga339540468510d05e8c4067666fb2d6ea">&#9670;&nbsp;</a></span>AEM13920_IsEnabledTempMon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_IsEnabledTempMon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>en</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the enabling status of the Temperature Monitoring. </p>
<p >This function reads the EN field of the TMON register and sets <code>en</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">en</td><td>Enabling status of the Temperature Monitoring </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>en</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>en</code> is set to <code>true</code> if the Temperature Monitoring is enabled, to <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="gac5d589f1e37205ac61b21cd279c99abe" name="gac5d589f1e37205ac61b21cd279c99abe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5d589f1e37205ac61b21cd279c99abe">&#9670;&nbsp;</a></span>AEM13920_SetSRCLOWConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_SetSRCLOWConfig </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___a_e_m13920___common.html#struct_a_e_m13920___s_r_c_l_o_w_c_f_g__t">AEM13920_SRCLOWCFG_t</a> *&#160;</td>
          <td class="paramname"><em>cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure both of the SRCLOW thresholds (SRC1 and SRC2) </p>
<p >This function writes the SRCLOW register to match the configuration set in <code>cfg</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cfg</td><td>SRCLOW thresholds configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>cfg</code> is correctly initialized </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The SRCLOW thresholds are set according to <code>cfg</code> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="ga0d11a959996e60a231455de8c2665bc4" name="ga0d11a959996e60a231455de8c2665bc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d11a959996e60a231455de8c2665bc4">&#9670;&nbsp;</a></span>AEM13920_GetSRCLOWConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetSRCLOWConfig </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#struct_a_e_m13920___s_r_c_l_o_w_c_f_g__t">AEM13920_SRCLOWCFG_t</a> *&#160;</td>
          <td class="paramname"><em>cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get both of the SRCLOW thresholds (SRC1 and SRC2) </p>
<p >This function reads the SRCLOW register and sets <code>cfg</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cfg</td><td>SRCLOW thresholds configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>cfg</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>cfg</code> is set with the configured SRCLOW thresholds </dd></dl>

</div>
</div>
<a id="gab5a1a027787bb9b45c96abf287c52097" name="gab5a1a027787bb9b45c96abf287c52097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5a1a027787bb9b45c96abf287c52097">&#9670;&nbsp;</a></span>AEM13920_SetSRCLowThresh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_SetSRCLowThresh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga77893383a955ca777943627c7fe48f4a">AEM13920_SRCLOW_THRESH</a>&#160;</td>
          <td class="paramname"><em>thresh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set SRCx' low threshold. </p>
<p >This function writes the SRCxTHRESH field of the SRCLOW register to match the threshold defined in <code>thresh</code>, where <code>x</code> is the selected source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Source </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thresh</td><td>SRCx low voltage threshold </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The SRCx low voltage threshold is set according to <code>thresh</code> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>AEM13920_EnableSleep() </dd></dl>

</div>
</div>
<a id="gaf0d59b4bf19eb9a784299a90567003f6" name="gaf0d59b4bf19eb9a784299a90567003f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0d59b4bf19eb9a784299a90567003f6">&#9670;&nbsp;</a></span>AEM13920_GetSRCLowThresh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetSRCLowThresh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga77893383a955ca777943627c7fe48f4a">AEM13920_SRCLOW_THRESH</a> *&#160;</td>
          <td class="paramname"><em>thresh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the configured low threshold for SRCx. </p>
<p >This function reads the SRCxTHRESH field of the SRCLOW register and sets <code>thresh</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Source </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">thresh</td><td>Configured SRCx low voltage threshold </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>thresh</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>thresh</code> is set according to the configured threshold </dd></dl>

</div>
</div>
<a id="ga2796ae865a8200a976d51c2811c6226c" name="ga2796ae865a8200a976d51c2811c6226c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2796ae865a8200a976d51c2811c6226c">&#9670;&nbsp;</a></span>AEM13920_SetAPMConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_SetAPMConfig </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___a_e_m13920___common.html#struct_a_e_m13920___a_p_m_c_f_g__t">AEM13920_APMCFG_t</a> *&#160;</td>
          <td class="paramname"><em>cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the APM configuration. </p>
<p >This function writes the APM register according to <code>cfg</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cfg</td><td>APM configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>cfg</code> is correctly initialized </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The APM configuration is set according to <code>cfg</code> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="gae52253bcb167e27e12b06d5239ad23b3" name="gae52253bcb167e27e12b06d5239ad23b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae52253bcb167e27e12b06d5239ad23b3">&#9670;&nbsp;</a></span>AEM13920_GetAPMConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetAPMConfig </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#struct_a_e_m13920___a_p_m_c_f_g__t">AEM13920_APMCFG_t</a> *&#160;</td>
          <td class="paramname"><em>cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the APM configuration. </p>
<p >This function reads the APM register and sets <code>cfg</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cfg</td><td>APM configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>cfg</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>cfg</code> is set according to the APM configuration </dd></dl>

</div>
</div>
<a id="gaa9568bdb4876bfe0197b215af57023ae" name="gaa9568bdb4876bfe0197b215af57023ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9568bdb4876bfe0197b215af57023ae">&#9670;&nbsp;</a></span>AEM13920_EnableAPMSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_EnableAPMSource </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a>&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the Average Power Monitoring for the selected source. </p>
<p >This function sets the SRCxEN field of the APM register, where <code>x</code> is the selected source</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Selected source </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The Average Power Monitoring is enabled for the selected source </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga1ecc1a13b7ae18d526fcf98e4106a4a0" title="Configure the APM functioning mode.">AEM13920_SetAPMMode()</a> </dd>
<dd>
<a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gad6baf3228367415fe8a3d87458514afa" title="Configure the APM computation window.">AEM13920_SetAPMWindow()</a> </dd></dl>

</div>
</div>
<a id="gac21c6b501829f9249103d0f2b1d62b50" name="gac21c6b501829f9249103d0f2b1d62b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac21c6b501829f9249103d0f2b1d62b50">&#9670;&nbsp;</a></span>AEM13920_DisableAPMSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_DisableAPMSource </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a>&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the Average Power Monitoring for the selected source. </p>
<p >This function clears the SRCxEN field of the APM register, where <code>x</code> is the selected source</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Selected source </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The Average Power Monitoring is disabled for the selected source </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="ga6bfb53f3f2d90964f10fd9ceb2260070" name="ga6bfb53f3f2d90964f10fd9ceb2260070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bfb53f3f2d90964f10fd9ceb2260070">&#9670;&nbsp;</a></span>AEM13920_IsEnabledAPMSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_IsEnabledAPMSource </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>en</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the enabling status of the Average Power Monitoring for the selected source. </p>
<p >This function reads the SRCxEN field of the APM register, where <code>x</code> is the selected source, and sets <code>en</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Selected source </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">en</td><td>Enabling status of the APM feature </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>en</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>en</code> is set to <code>true</code> if the APM feature is enabled for the selected source, to <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="gab937a6dec346efc1668d12d3aec36fa8" name="gab937a6dec346efc1668d12d3aec36fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab937a6dec346efc1668d12d3aec36fa8">&#9670;&nbsp;</a></span>AEM13920_EnableAPMBuck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_EnableAPMBuck </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the Average Power Monitoring for the buck converter. </p>
<p >This function sets the BUCKEN field of the APM register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The Average Power Monitoring is enabled for the buck converter </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#ga1ecc1a13b7ae18d526fcf98e4106a4a0" title="Configure the APM functioning mode.">AEM13920_SetAPMMode()</a> </dd>
<dd>
<a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gad6baf3228367415fe8a3d87458514afa" title="Configure the APM computation window.">AEM13920_SetAPMWindow()</a> </dd></dl>

</div>
</div>
<a id="gacd193765764685a073e05380dfc43586" name="gacd193765764685a073e05380dfc43586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd193765764685a073e05380dfc43586">&#9670;&nbsp;</a></span>AEM13920_DisableAPMBuck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_DisableAPMBuck </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the Average Power Monitoring for the buck converter. </p>
<p >This function clears the BUCKEN field of the APM register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The Average Power Monitoring is disabled for the buck converter </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="ga0a87eda4ed1c00b1b0a2b6957cedbd24" name="ga0a87eda4ed1c00b1b0a2b6957cedbd24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a87eda4ed1c00b1b0a2b6957cedbd24">&#9670;&nbsp;</a></span>AEM13920_IsEnabledAPMBuck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_IsEnabledAPMBuck </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>en</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the enabling status of the Average Power Monitoring for the buck converter. </p>
<p >This function reads the BUCKEN field of the APM register and sets <code>en</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">en</td><td>Enabling status of the APM feature </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>en</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>en</code> is set to <code>true</code> if the APM feature is enabled for the buck converter, to <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="ga1ecc1a13b7ae18d526fcf98e4106a4a0" name="ga1ecc1a13b7ae18d526fcf98e4106a4a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ecc1a13b7ae18d526fcf98e4106a4a0">&#9670;&nbsp;</a></span>AEM13920_SetAPMMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_SetAPMMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga14afbba9f4eb5541a246f6993103c0be">AEM13920_APM_MODE</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the APM functioning mode. </p>
<p >This function writes the MODE field of the APM register according to <code>mode</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>APM mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>mode</code> is a valid <a class="el" href="group___a_e_m13920___common.html#ga14afbba9f4eb5541a246f6993103c0be">AEM13920_APM_MODE</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The APM functioning mode is set according to <code>mode</code> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This configuration has no effect if the Average Power Monitoring is not enabled </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaa9568bdb4876bfe0197b215af57023ae" title="Enable the Average Power Monitoring for the selected source.">AEM13920_EnableAPMSource()</a> and <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gab937a6dec346efc1668d12d3aec36fa8" title="Enable the Average Power Monitoring for the buck converter.">AEM13920_EnableAPMBuck()</a> </dd></dl>

</div>
</div>
<a id="ga4be229f12a95385f3eeb7ae41a736dd9" name="ga4be229f12a95385f3eeb7ae41a736dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4be229f12a95385f3eeb7ae41a736dd9">&#9670;&nbsp;</a></span>AEM13920_GetAPMMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetAPMMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga14afbba9f4eb5541a246f6993103c0be">AEM13920_APM_MODE</a> *&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the configured APM mode. </p>
<p >This function reads the MODE field of the APM register and sets <code>mode</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mode</td><td>Configured APM mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>mode</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>mode</code> is set with the configured APM mode </dd></dl>

</div>
</div>
<a id="gad6baf3228367415fe8a3d87458514afa" name="gad6baf3228367415fe8a3d87458514afa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6baf3228367415fe8a3d87458514afa">&#9670;&nbsp;</a></span>AEM13920_SetAPMWindow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_SetAPMWindow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#gaef0ae0015f6f8a0e3c47710718d5ac84">AEM13920_APM_WINDOW</a>&#160;</td>
          <td class="paramname"><em>window</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the APM computation window. </p>
<p >This function writes the WINDOW field of the APM register according to <code>window</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">window</td><td>Computation window </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>window</code> is a valid <a class="el" href="group___a_e_m13920___common.html#gaef0ae0015f6f8a0e3c47710718d5ac84">AEM13920_APM_WINDOW</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The APM computation window is set according to <code>window</code> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This configuration has no effect if the Average Power Monitoring is not enabled </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaa9568bdb4876bfe0197b215af57023ae" title="Enable the Average Power Monitoring for the selected source.">AEM13920_EnableAPMSource()</a> and <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gab937a6dec346efc1668d12d3aec36fa8" title="Enable the Average Power Monitoring for the buck converter.">AEM13920_EnableAPMBuck()</a> </dd></dl>

</div>
</div>
<a id="ga3142c90829bccaa6b01d7ee274951ce8" name="ga3142c90829bccaa6b01d7ee274951ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3142c90829bccaa6b01d7ee274951ce8">&#9670;&nbsp;</a></span>AEM13920_GetAPMWindow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetAPMWindow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#gaef0ae0015f6f8a0e3c47710718d5ac84">AEM13920_APM_WINDOW</a> *&#160;</td>
          <td class="paramname"><em>window</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the configured APM computation window. </p>
<p >This function reads the WINDOW field of the APM register and sets <code>window</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">window</td><td>Configured APM computation window </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>window</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>window</code> is set with the configured APM computation window </dd></dl>

</div>
</div>
<a id="ga44f0fff820087885425b9f5a1ef03ba6" name="ga44f0fff820087885425b9f5a1ef03ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44f0fff820087885425b9f5a1ef03ba6">&#9670;&nbsp;</a></span>AEM13920_SetIRQConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_SetIRQConfig </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___a_e_m13920___common.html#struct_a_e_m13920___i_r_q_e_n__t">AEM13920_IRQEN_t</a> *&#160;</td>
          <td class="paramname"><em>irqs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the AEM's IRQs. </p>
<p >This function writes the IRQEN0 and IRQEN1 registers according to <code>irqs</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">irqs</td><td>IRQ's configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>irqs</code> is correctly initialized </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The AEM's IRQ are configured according to <code>irqs</code> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="ga2fbb54c6968fcc79cd6db4b123a5c4fe" name="ga2fbb54c6968fcc79cd6db4b123a5c4fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fbb54c6968fcc79cd6db4b123a5c4fe">&#9670;&nbsp;</a></span>AEM13920_GetIRQConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetIRQConfig </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#struct_a_e_m13920___i_r_q_e_n__t">AEM13920_IRQEN_t</a> *&#160;</td>
          <td class="paramname"><em>irqs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the configuration of the IRQs. </p>
<p >This function reads the IRQEN0 and IRQEN1 registers and sets <code>irqs</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">irqs</td><td>Configuration of the IRQs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>irqs</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>irqs</code> is set with the configuration of the IRQs </dd></dl>

</div>
</div>
<a id="ga07b567699ab2251c104e0f4287c2bb75" name="ga07b567699ab2251c104e0f4287c2bb75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07b567699ab2251c104e0f4287c2bb75">&#9670;&nbsp;</a></span>AEM13920_EnableI2CReadyIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_EnableI2CReadyIRQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the I2CRDY IRQ. </p>
<p >This function sets the I2CRDY field of the IRQEN0 register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The IRQ pin is asserted (HIGH) when the AEM is out of reset and ready to communicate through I2C </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="ga45806bc9afe8c606acde88ff147c261a" name="ga45806bc9afe8c606acde88ff147c261a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45806bc9afe8c606acde88ff147c261a">&#9670;&nbsp;</a></span>AEM13920_DisableI2CReadyIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_DisableI2CReadyIRQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the I2CRDY IRQ. </p>
<p >This function clears the I2CRDY field of the IRQEN0 register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The IRQ pin is not asserted when the AEM is out of reset and ready to communicate through I2C </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="ga205820da109c68f032db4d7140562a1f" name="ga205820da109c68f032db4d7140562a1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga205820da109c68f032db4d7140562a1f">&#9670;&nbsp;</a></span>AEM13920_IsEnabledI2CReadyIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_IsEnabledI2CReadyIRQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>en</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the enabling status of the I2CRDY IRQ. </p>
<p >This functions reads the I2CRDY field of the IRQEN0 register and sets <code>en</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">en</td><td>The enabling status of the I2C ready IRQ </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>en</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>en</code> is set to <code>true</code> if the assertion of the IRQ pin on I2C ready condition is enabled, to <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="gae1a20f851900703ba24418b05d04e6ee" name="gae1a20f851900703ba24418b05d04e6ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1a20f851900703ba24418b05d04e6ee">&#9670;&nbsp;</a></span>AEM13920_EnableOverdischargeIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_EnableOverdischargeIRQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the VOVDIS IRQ. </p>
<p >This function sets the VOVDIS field of the IRQEN0 register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The IRQ pin is asserted (HIGH) when the storage level crosses the overdischarge threshold </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="gad2619b95da5d2c215aa2bd24a3e1289d" name="gad2619b95da5d2c215aa2bd24a3e1289d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2619b95da5d2c215aa2bd24a3e1289d">&#9670;&nbsp;</a></span>AEM13920_DisableOverdischargeIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_DisableOverdischargeIRQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the VOVDIS IRQ. </p>
<p >This function clears the VOVDIS field of the IRQEN0 register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The IRQ pin is not asserted when the storage level crosses the overdischarge threshold </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="gaa1a517bb8c3bddaeb876bbfa3b755085" name="gaa1a517bb8c3bddaeb876bbfa3b755085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1a517bb8c3bddaeb876bbfa3b755085">&#9670;&nbsp;</a></span>AEM13920_IsEnabledOverdischargeIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_IsEnabledOverdischargeIRQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>en</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the enabling status of the VOVDIS IRQ. </p>
<p >This functions reads the VOVDIS field of the IRQEN0 register and sets <code>en</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">en</td><td>The enabling status of the VOVDIS IRQ </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>en</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>en</code> is set to <code>true</code> if the assertion of the IRQ pin on VOVDIS condition is enabled, to <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="gabc22719968236fd365da1c7957cb5b21" name="gabc22719968236fd365da1c7957cb5b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc22719968236fd365da1c7957cb5b21">&#9670;&nbsp;</a></span>AEM13920_EnableChargeReadyIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_EnableChargeReadyIRQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the VCHRDY IRQ. </p>
<p >This function sets the VCHRDY field of the IRQEN0 register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The IRQ pin is asserted (HIGH) when the storage level crosses the charge ready threshold </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="ga2068fc749337dedf76356bd80c5eb641" name="ga2068fc749337dedf76356bd80c5eb641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2068fc749337dedf76356bd80c5eb641">&#9670;&nbsp;</a></span>AEM13920_DisableChargeReadyIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_DisableChargeReadyIRQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the VCHRDY IRQ. </p>
<p >This function clears the VCHRDY field of the IRQEN0 register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The IRQ pin is not asserted when the storage level crosses the charge ready threshold </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="gad1df1aca75f445663bedac286846ab9a" name="gad1df1aca75f445663bedac286846ab9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1df1aca75f445663bedac286846ab9a">&#9670;&nbsp;</a></span>AEM13920_IsEnabledChargeReadyIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_IsEnabledChargeReadyIRQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>en</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the enabling status of the VCHRDY IRQ. </p>
<p >This functions reads the VCHRDY field of the IRQEN0 register and sets <code>en</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">en</td><td>The enabling status of the Charge Ready IRQ </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>en</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>en</code> is set to <code>true</code> if the assertion of the IRQ pin on VCHRDY condition is enabled, to <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="gaf8bd3588fcd896e931cc48bc2e786ee4" name="gaf8bd3588fcd896e931cc48bc2e786ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8bd3588fcd896e931cc48bc2e786ee4">&#9670;&nbsp;</a></span>AEM13920_EnableOverchargeIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_EnableOverchargeIRQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable VOVCH IRQ. </p>
<p >This function sets the VOVCH field of the IRQEN0 register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The IRQ pin is asserted (HIGH) when the storage level crosses the overcharge threshold </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="ga0e52012ebc73c24f6ccbd0bb0679d3b1" name="ga0e52012ebc73c24f6ccbd0bb0679d3b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e52012ebc73c24f6ccbd0bb0679d3b1">&#9670;&nbsp;</a></span>AEM13920_DisableOverchargeIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_DisableOverchargeIRQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the VOVCH IRQ. </p>
<p >This function clears the VOVCH field of the IRQEN0 register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The IRQ pin is not asserted when the storage level crosses the overcharge threshold </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="ga774c0430c4cd229596e7a521aeaf41f9" name="ga774c0430c4cd229596e7a521aeaf41f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga774c0430c4cd229596e7a521aeaf41f9">&#9670;&nbsp;</a></span>AEM13920_IsEnabledOverchargeIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_IsEnabledOverchargeIRQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>en</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the enabling status of the VOVCH IRQ. </p>
<p >This functions reads the VOVCH field of the IRQEN0 register and sets <code>en</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">en</td><td>The enabling status of the VOVCH IRQ </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>en</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>en</code> is set to <code>true</code> if the assertion of the IRQ pin on VOVCH condition is enabled, to <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="ga5108f7355ef58c98fa62366c8eb71866" name="ga5108f7355ef58c98fa62366c8eb71866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5108f7355ef58c98fa62366c8eb71866">&#9670;&nbsp;</a></span>AEM13920_EnableSRCLowIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_EnableSRCLowIRQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable SRCLOW IRQ. </p>
<p >This function sets the SRCLOW field of the IRQEN0 register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The IRQ pin is asserted (HIGH) on any transition between a state where at least one source voltage is above its low threshold and a state where both are below their respective low thresholds. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="ga0102df27221ad96501df3f6a1fbd4db6" name="ga0102df27221ad96501df3f6a1fbd4db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0102df27221ad96501df3f6a1fbd4db6">&#9670;&nbsp;</a></span>AEM13920_DisableSRCLowIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_DisableSRCLowIRQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the SRCLOW IRQ. </p>
<p >This function clears the SRCLOW field of the IRQEN0 register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The IRQ pin is not asserted on SRCLOW condition. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="gadd000d6e8d1a1229d11eb9c4bbffb88b" name="gadd000d6e8d1a1229d11eb9c4bbffb88b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd000d6e8d1a1229d11eb9c4bbffb88b">&#9670;&nbsp;</a></span>AEM13920_IsEnabledSRCLowIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_IsEnabledSRCLowIRQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>en</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the enabling status of the SRCLOW IRQ. </p>
<p >This functions reads the SRCLOW field of the IRQEN0 register and sets <code>en</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">en</td><td>The enabling status of the SRCLOW IRQ </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>en</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>en</code> is set to <code>true</code> if the assertion of the IRQ pin on SRCLOW condition is enabled, to <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="ga79561e76e526e985c37c011b43dd15ab" name="ga79561e76e526e985c37c011b43dd15ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79561e76e526e985c37c011b43dd15ab">&#9670;&nbsp;</a></span>AEM13920_EnableTempChargeIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_EnableTempChargeIRQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable TEMPCH IRQ. </p>
<p >This function sets the TEMPCH field of the IRQEN0 register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The IRQ pin is asserted (HIGH) when the ambient temperature is out of the defined range for charging </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="ga5f9268483b1a49aaeca9472874f9febd" name="ga5f9268483b1a49aaeca9472874f9febd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f9268483b1a49aaeca9472874f9febd">&#9670;&nbsp;</a></span>AEM13920_DisableTempChargeIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_DisableTempChargeIRQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the TEMPCH IRQ. </p>
<p >This function clears the TEMPCH field of the IRQEN0 register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The IRQ pin is not asserted when the ambient temperature is out of the defined range for charging </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="ga46a19e4851c2ffc0b539bcfdc685cf7e" name="ga46a19e4851c2ffc0b539bcfdc685cf7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46a19e4851c2ffc0b539bcfdc685cf7e">&#9670;&nbsp;</a></span>AEM13920_IsEnabledTempChargeIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_IsEnabledTempChargeIRQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>en</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the enabling status of the TEMPCH IRQ. </p>
<p >This functions reads the TEMPCH field of the IRQEN0 register and sets <code>en</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">en</td><td>The enabling status of the TEMP IRQ </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>en</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>en</code> is set to <code>true</code> if the assertion of the IRQ pin on TEMPCH condition is enabled, to <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="ga1570082386063a2dae19dbf6ddd029ea" name="ga1570082386063a2dae19dbf6ddd029ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1570082386063a2dae19dbf6ddd029ea">&#9670;&nbsp;</a></span>AEM13920_EnableTempDischargeIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_EnableTempDischargeIRQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable TEMPDIS IRQ. </p>
<p >This function sets the TEMPDIS field of the IRQEN0 register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The IRQ pin is asserted (HIGH) when the ambient temperature is out of the defined range for discharging </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="ga02bca5f6f374aaf7c203a236b90fc3d7" name="ga02bca5f6f374aaf7c203a236b90fc3d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02bca5f6f374aaf7c203a236b90fc3d7">&#9670;&nbsp;</a></span>AEM13920_DisableTempDischargeIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_DisableTempDischargeIRQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the TEMPDIS IRQ. </p>
<p >This function clears the TEMPDIS field of the IRQEN0 register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The IRQ pin is not asserted when the ambient temperature is out of the defined range for discharging </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="ga5f898b819dd266af6a5fbcae73b6ba29" name="ga5f898b819dd266af6a5fbcae73b6ba29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f898b819dd266af6a5fbcae73b6ba29">&#9670;&nbsp;</a></span>AEM13920_IsEnabledTempDischargeIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_IsEnabledTempDischargeIRQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>en</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the enabling status of the TEMPDIS IRQ. </p>
<p >This functions reads the TEMPDIS field of the IRQEN0 register and sets <code>en</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">en</td><td>The enabling status of the TEMPDIS IRQ </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>en</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>en</code> is set to <code>true</code> if the assertion of the IRQ pin on TEMPDIS condition is enabled, to <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="gaeef7b21964872d85c3d74945b5dd640b" name="gaeef7b21964872d85c3d74945b5dd640b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeef7b21964872d85c3d74945b5dd640b">&#9670;&nbsp;</a></span>AEM13920_EnableMPPTStartIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_EnableMPPTStartIRQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a>&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the MPPTSTART IRQ for the selected source. </p>
<p >This function sets the SRCxMPPTSTART field of the IRQEN1 register, where x is the selected source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Selected source </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>src</code> is a valid <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The IRQ pin is asserted (HIGH) when the MPPT starts for the selected source </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="ga7ba411b89acd3b75ec97e53b288b0a2c" name="ga7ba411b89acd3b75ec97e53b288b0a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ba411b89acd3b75ec97e53b288b0a2c">&#9670;&nbsp;</a></span>AEM13920_DisableMPPTStartIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_DisableMPPTStartIRQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a>&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the MPPTSTART IRQ for the selected source. </p>
<p >This function clears the SRCxMPPTSTART field of the IRQEN1 register, where x is the selected source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Selected source </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>src</code> is a valid <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The IRQ pin is not asserted when the MPPT starts for the selected source </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="ga7b3bd8aca148a5fdfb297efeadf971ba" name="ga7b3bd8aca148a5fdfb297efeadf971ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b3bd8aca148a5fdfb297efeadf971ba">&#9670;&nbsp;</a></span>AEM13920_IsEnabledMPPTStartIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_IsEnabledMPPTStartIRQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>en</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the enabling status of the MPPTSTART IRQ for the selected source. </p>
<p >This functions reads the SRCxMPPTSTART field of the IRQEN1 register, where x is the selected source, and sets <code>en</code> accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Selected source </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">en</td><td>The enabling status of the MPPT Start IRQ </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>src</code> is a valid <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> </dd>
<dd>
<code>en</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>en</code> is set to <code>true</code> if the assertion of the IRQ pin on SRCxMPPTSTART condition is enabled, to <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="ga0935e0d623a8092aaf813a85776aa18d" name="ga0935e0d623a8092aaf813a85776aa18d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0935e0d623a8092aaf813a85776aa18d">&#9670;&nbsp;</a></span>AEM13920_EnableMPPTDoneIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_EnableMPPTDoneIRQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a>&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the MPPTDONE IRQ for the selected source. </p>
<p >This function sets the SRCxMPPTDONE field of the IRQEN1 register, where x is the selected source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Selected source </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>src</code> is a valid <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The IRQ pin is asserted (HIGH) when the MPPT is done for the selected source </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="ga7af7f49021f7c1fa3d8eea7e10c688d3" name="ga7af7f49021f7c1fa3d8eea7e10c688d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7af7f49021f7c1fa3d8eea7e10c688d3">&#9670;&nbsp;</a></span>AEM13920_DisableMPPTDoneIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_DisableMPPTDoneIRQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a>&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the MPPTDONE IRQ for the selected source. </p>
<p >This function clears the SRCxMPPTDONE field of the IRQEN1 register, where x is the selected source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Selected source </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>src</code> is a valid <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The IRQ pin is not asserted when the MPPT is done for the selected source </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="gac337df212e729d35e05606e2806898ee" name="gac337df212e729d35e05606e2806898ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac337df212e729d35e05606e2806898ee">&#9670;&nbsp;</a></span>AEM13920_IsEnabledMPPTDoneIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_IsEnabledMPPTDoneIRQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>en</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the enabling status of the MPPTDONE IRQ for the selected source. </p>
<p >This functions reads the SRCxMPPTDONE field of the IRQEN1 register, where x is the selected source, and sets <code>en</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Selected source </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">en</td><td>The enabling status of the MPPT Done IRQ </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>src</code> is a valid <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> </dd>
<dd>
<code>en</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>en</code> is set to <code>true</code> if the assertion of the IRQ pin on SRCxMPPTDONE condition is enabled, to <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="gacffe976ae8ddda0ac1e6cc926f0dfe5e" name="gacffe976ae8ddda0ac1e6cc926f0dfe5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacffe976ae8ddda0ac1e6cc926f0dfe5e">&#9670;&nbsp;</a></span>AEM13920_EnableSTODoneIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_EnableSTODoneIRQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the STODONE IRQ. </p>
<p >This function sets the STODONE field of the IRQEN1 register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The IRQ pin is asserted (HIGH) when the STO measurement is done </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="ga46f23da8407fbc778ad28b53f0c7ed72" name="ga46f23da8407fbc778ad28b53f0c7ed72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46f23da8407fbc778ad28b53f0c7ed72">&#9670;&nbsp;</a></span>AEM13920_DisableSTODoneIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_DisableSTODoneIRQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the STODONE IRQ. </p>
<p >This function clears the STODONE field of the IRQEN1 register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The IRQ pin is not asserted when the STO measurement is done </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="ga5c6a4753a1d43e9dacaa9c58fe275ac0" name="ga5c6a4753a1d43e9dacaa9c58fe275ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c6a4753a1d43e9dacaa9c58fe275ac0">&#9670;&nbsp;</a></span>AEM13920_IsEnabledSTODoneIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_IsEnabledSTODoneIRQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>en</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the enabling status of the STODONE IRQ. </p>
<p >This functions reads the STODONE field of the IRQEN1 register and sets <code>en</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">en</td><td>The enabling status of the STO Done IRQ </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>en</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>en</code> is set to <code>true</code> if the assertion of the IRQ pin on STODONE condition is enabled, to <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="ga43f81ad2c94268d39b91332143826d24" name="ga43f81ad2c94268d39b91332143826d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43f81ad2c94268d39b91332143826d24">&#9670;&nbsp;</a></span>AEM13920_EnableTempDoneIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_EnableTempDoneIRQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the TEMPDONE IRQ. </p>
<p >This function sets the TEMPDONE field of the IRQEN1 register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The IRQ pin is asserted (HIGH) when the temperature measurement is done </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="ga4e6e9ef8c2c3e5715cc3f19a85c8ece2" name="ga4e6e9ef8c2c3e5715cc3f19a85c8ece2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e6e9ef8c2c3e5715cc3f19a85c8ece2">&#9670;&nbsp;</a></span>AEM13920_DisableTempDoneIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_DisableTempDoneIRQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the TEMPDONE IRQ. </p>
<p >This function clears the TEMPDONE field of the IRQEN1 register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The IRQ pin is not asserted when the temperature measurement is done </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="ga0c8290c750e110b2bbe17826ff540310" name="ga0c8290c750e110b2bbe17826ff540310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c8290c750e110b2bbe17826ff540310">&#9670;&nbsp;</a></span>AEM13920_IsEnabledTempDoneIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_IsEnabledTempDoneIRQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>en</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the enabling status of the TEMPDONE IRQ. </p>
<p >This functions reads the TEMPDONE field of the IRQEN1 register and sets <code>en</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">en</td><td>The enabling status of the TEMP Done IRQ </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>en</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>en</code> is set to <code>true</code> if the assertion of the IRQ pin on TEMPDONE condition is enabled, to <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="ga9bd247eb2e2dc1a3dd6c2b9486296a2e" name="ga9bd247eb2e2dc1a3dd6c2b9486296a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9bd247eb2e2dc1a3dd6c2b9486296a2e">&#9670;&nbsp;</a></span>AEM13920_EnableAPMDoneIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_EnableAPMDoneIRQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable APMDONE IRQ. </p>
<p >This function sets the APMDONE field of the IRQEN1 register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The IRQ pin is asserted (HIGH) when new APM data is available </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="ga932e263d4ca77adff40d5250eb15e8a8" name="ga932e263d4ca77adff40d5250eb15e8a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga932e263d4ca77adff40d5250eb15e8a8">&#9670;&nbsp;</a></span>AEM13920_DisableAPMDoneIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_DisableAPMDoneIRQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the APMDONE IRQ. </p>
<p >This function clears the APMDONE field of the IRQEN1 register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The IRQ pin is not asserted when new APM data is available </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="ga69a8b2219036a6d7ee13dc36acde2ac2" name="ga69a8b2219036a6d7ee13dc36acde2ac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69a8b2219036a6d7ee13dc36acde2ac2">&#9670;&nbsp;</a></span>AEM13920_IsEnabledAPMDoneIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_IsEnabledAPMDoneIRQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>en</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the enabling status of the APMDONE IRQ. </p>
<p >This functions reads the APMDONE field of the IRQEN1 register and sets <code>en</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">en</td><td>The enabling status of the APMDONE IRQ </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>en</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>en</code> is set to <code>true</code> if the assertion of the IRQ pin on APMDONE condition is enabled, to <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="ga7c72bcb6ec638ab6231b7f09d52a2b96" name="ga7c72bcb6ec638ab6231b7f09d52a2b96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c72bcb6ec638ab6231b7f09d52a2b96">&#9670;&nbsp;</a></span>AEM13920_EnableAPMErrIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_EnableAPMErrIRQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the APMERR IRQ. </p>
<p >This function sets the APMERR field of the IRQEN1 register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The IRQ pin is asserted (HIGH) when an APM error occurs </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="gaa2f63da50b811cbc33af1a3ee5c70249" name="gaa2f63da50b811cbc33af1a3ee5c70249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2f63da50b811cbc33af1a3ee5c70249">&#9670;&nbsp;</a></span>AEM13920_DisableAPMErrIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_DisableAPMErrIRQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the APMERR IRQ. </p>
<p >This function clears the APMERR field of the IRQEN1 register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The IRQ pin is not asserted when an APM error occurs </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The AEM configuration is not updated until the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function is called. </dd></dl>

</div>
</div>
<a id="gae46fe8b8aab9586546cd0d4151b39bd5" name="gae46fe8b8aab9586546cd0d4151b39bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae46fe8b8aab9586546cd0d4151b39bd5">&#9670;&nbsp;</a></span>AEM13920_IsEnabledAPMErrIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_IsEnabledAPMErrIRQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>en</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the enabling status of the APMERR IRQ. </p>
<p >This functions reads the APMERR field of the IRQEN1 register and sets <code>en</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">en</td><td>The enabling status of the APMERR IRQ </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>en</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>en</code> is set to <code>true</code> if the assertion of the IRQ pin on APMERR condition is enabled, to <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="gaa9b31c72036572a080787a83e0c86e69" name="gaa9b31c72036572a080787a83e0c86e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9b31c72036572a080787a83e0c86e69">&#9670;&nbsp;</a></span>AEM13920_SetConfigurationMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_SetConfigurationMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga1f8360223fa5e4657b6bfd75107e9653">AEM13920_CONFIG_MODE</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the configuration mode (I2C or GPIO) </p>
<p >This function writes the UPDATE field of the CTRL register according to <code>mode</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Mode of configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>mode</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The configuration mode is set according to <code>mode</code> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>When selecting the I2C mode, this function has the side-effect of starting a synchronization of the I2C registers, making it equivalent to a call to the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> function </dd></dl>

</div>
</div>
<a id="gacad1361d510337c7cb2aff2ec7c706d0" name="gacad1361d510337c7cb2aff2ec7c706d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacad1361d510337c7cb2aff2ec7c706d0">&#9670;&nbsp;</a></span>AEM13920_GetConfigurationMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetConfigurationMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga1f8360223fa5e4657b6bfd75107e9653">AEM13920_CONFIG_MODE</a> *&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the active configuration mode (I2C or GPIO) </p>
<p >This function reads the UPDATE field of the CTRL register, and sets <code>mode</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mode</td><td>Mode of configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>mode</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>mode</code> is set according to the AEM configuration mode </dd></dl>

</div>
</div>
<a id="gaf9b9937cb783cd9118b630f6cd8b6b9b" name="gaf9b9937cb783cd9118b630f6cd8b6b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9b9937cb783cd9118b630f6cd8b6b9b">&#9670;&nbsp;</a></span>AEM13920_SyncI2CConfiguration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_SyncI2CConfiguration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load the I2C configuration. </p>
<p >This function sets the UPDATE field of the CTRL register. If <code>blocking</code> is set to <code>true</code>, the function blocks until the synchronisation is complete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blocking</td><td>Whether the call shall be blocking </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>A synchronization of the I2C registers has been requested </dd>
<dd>
If <code>blocking</code> is set to <code>true</code>, the function blocks until the synchronization is complete </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <code>blocking</code> is not set to true, the function does not block, and the synchronization status can be monitored using the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gabda7c3d01846fc9825dcfff754770422" title="Get the I2C synchronization busy flag.">AEM13920_IsSyncingI2CConfiguration()</a> function </dd></dl>

</div>
</div>
<a id="gabda7c3d01846fc9825dcfff754770422" name="gabda7c3d01846fc9825dcfff754770422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabda7c3d01846fc9825dcfff754770422">&#9670;&nbsp;</a></span>AEM13920_IsSyncingI2CConfiguration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_IsSyncingI2CConfiguration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>syncing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the I2C synchronization busy flag. </p>
<p >This function reads the SYNCBUSY field of the CTRL register, and sets <code>syncing</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">syncing</td><td>Synchronization flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>syncing</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>syncing</code> is set to <code>true</code> if the synchronization of the I2C registers and the system registers is ongoing, to <code>false</code> otherwise </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use this function after calls to the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gaf9b9937cb783cd9118b630f6cd8b6b9b" title="Load the I2C configuration.">AEM13920_SyncI2CConfiguration()</a> or AEM13920_Configure() functions to ensure the synchronization is complete before any attempt to read the configuration </dd></dl>

</div>
</div>
<a id="ga10f70e674915c959362ad7fa24855030" name="ga10f70e674915c959362ad7fa24855030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10f70e674915c959362ad7fa24855030">&#9670;&nbsp;</a></span>AEM13920_GetChipVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetChipVersion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the chip version. </p>
<p >This function reads the VERSION register, and sets <code>version</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">version</td><td>Chip version </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>version</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>version</code> is set with the chip version </dd></dl>

</div>
</div>
<a id="ga9b84b275a2a8db80371977860e695863" name="ga9b84b275a2a8db80371977860e695863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b84b275a2a8db80371977860e695863">&#9670;&nbsp;</a></span>AEM13920_GetIRQFlags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetIRQFlags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#struct_a_e_m13920___i_r_q_f_l_g__t">AEM13920_IRQFLG_t</a> *&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the AEM's interrupt flags. </p>
<p >This function reads the IRQFLG0 and IRQFLG1 registers, and sets <code>flags</code> accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flags</td><td>Interrupt flags </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>flags</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>flags</code> is set with the IRQ flags </dd></dl>

</div>
</div>
<a id="gac72074e1960978dcb49c39fee7f5fa45" name="gac72074e1960978dcb49c39fee7f5fa45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac72074e1960978dcb49c39fee7f5fa45">&#9670;&nbsp;</a></span>AEM13920_GetI2CReadyFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetI2CReadyFlag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the I2C ready IRQ flag. </p>
<p >This functions reads the I2CRDY field of the IRQFLG0 register and sets <code>flag</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flag</td><td>I2CRDY IRQ flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>flag</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>flag</code> is set to <code>true</code> if the I2C ready IRQ flag is raised, to <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="gae4a483850182599b77642b1cde5971e2" name="gae4a483850182599b77642b1cde5971e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4a483850182599b77642b1cde5971e2">&#9670;&nbsp;</a></span>AEM13920_GetOverdischargeFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetOverdischargeFlag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the overdischarge IRQ flag. </p>
<p >This functions reads the VOVDIS field of the IRQFLG0 register and sets <code>flag</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flag</td><td>VOVDIS IRQ flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>flag</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>flag</code> is set to <code>true</code> if the overdischarge IRQ flag is raised, to <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="ga8ac5f9860f58bd601b7d703c818e9666" name="ga8ac5f9860f58bd601b7d703c818e9666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ac5f9860f58bd601b7d703c818e9666">&#9670;&nbsp;</a></span>AEM13920_GetChargeReadyFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetChargeReadyFlag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the charge ready IRQ flag. </p>
<p >This functions reads the VCHRDY field of the IRQFLG0 register and sets <code>flag</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flag</td><td>VCHRDY IRQ flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>flag</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>flag</code> is set to <code>true</code> if the charge ready IRQ flag is raised, to <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="gaa146248af14c5313b39dc38b4b2aadb5" name="gaa146248af14c5313b39dc38b4b2aadb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa146248af14c5313b39dc38b4b2aadb5">&#9670;&nbsp;</a></span>AEM13920_GetOverchargeFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetOverchargeFlag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the overcharge IRQ flag. </p>
<p >This functions reads the VOVCH field of the IRQFLG0 register and sets <code>flag</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flag</td><td>VOVCH IRQ flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>flag</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>flag</code> is set to <code>true</code> if the overcharge IRQ flag is raised, to <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="ga9d3d44f9a8b8cfba2593a80461ed1bb4" name="ga9d3d44f9a8b8cfba2593a80461ed1bb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d3d44f9a8b8cfba2593a80461ed1bb4">&#9670;&nbsp;</a></span>AEM13920_GetSRCLowFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetSRCLowFlag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the SRCLOW IRQ flag. </p>
<p >This functions reads the SRCLOW field of the IRQFLG0 register and sets <code>flag</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flag</td><td>SRCLOW IRQ flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>flag</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>flag</code> is set to <code>true</code> if the SRCLOW IRQ flag is raised, to <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="ga76bbc3a8ef432961e49edbbc7e76ba48" name="ga76bbc3a8ef432961e49edbbc7e76ba48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76bbc3a8ef432961e49edbbc7e76ba48">&#9670;&nbsp;</a></span>AEM13920_GetTempChargeFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetTempChargeFlag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the temperature (charge) IRQ flag. </p>
<p >This functions reads the TEMPCH field of the IRQFLG0 register and sets <code>flag</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flag</td><td>TEMPCH IRQ flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>flag</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>flag</code> is set to <code>true</code> if the temperature (charge) IRQ flag is raised, to <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="gade215d0e45a3ca4aba945b790bf9c21f" name="gade215d0e45a3ca4aba945b790bf9c21f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade215d0e45a3ca4aba945b790bf9c21f">&#9670;&nbsp;</a></span>AEM13920_GetTempDischargeFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetTempDischargeFlag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the temperature (discharge) IRQ flag. </p>
<p >This functions reads the TEMPDIS field of the IRQFLG0 register and sets <code>flag</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flag</td><td>TEMPDIS IRQ flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>flag</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>flag</code> is set to <code>true</code> if the temperature (discharge) IRQ flag is raised, to <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="ga8829e15fe5a5b3a344c4fcfe4faea223" name="ga8829e15fe5a5b3a344c4fcfe4faea223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8829e15fe5a5b3a344c4fcfe4faea223">&#9670;&nbsp;</a></span>AEM13920_GetMPPTStartFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetMPPTStartFlag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the MPPT Start IRQ flag for the selected source. </p>
<p >This functions reads the SRCxMPPTSTART field of the IRQFLG1 register, where x is the selected source, and sets <code>flag</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Selected source </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flag</td><td>SRCxMPPTSTART IRQ flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>src</code> is a valid <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> </dd>
<dd>
<code>flag</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>flag</code> is set to <code>true</code> if the MPPT start IRQ flag is raised for the selected source, to <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="ga188e88a4d228017f9cf29b9526931dce" name="ga188e88a4d228017f9cf29b9526931dce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga188e88a4d228017f9cf29b9526931dce">&#9670;&nbsp;</a></span>AEM13920_GetMPPTDoneFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetMPPTDoneFlag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the MPPT Done IRQ flag for the selected source. </p>
<p >This functions reads the SRCxMPPTDONE field of the IRQFLG1 register, where x is the selected source, and sets <code>flag</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Selected source </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flag</td><td>SRCxMPPTDONE IRQ flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>src</code> is a valid <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> </dd>
<dd>
<code>flag</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>flag</code> is set to <code>true</code> if the MPPT done IRQ flag is raised for the selected source, to <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="gacf3f28881283620fdde926136cace2eb" name="gacf3f28881283620fdde926136cace2eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf3f28881283620fdde926136cace2eb">&#9670;&nbsp;</a></span>AEM13920_GetSTODoneFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetSTODoneFlag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the STO Done IRQ flag. </p>
<p >This functions reads the STODONE field of the IRQFLG1 register and sets <code>flag</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flag</td><td>STODONE IRQ flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>flag</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>flag</code> is set to <code>true</code> if the STO done IRQ flag is raised, to <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="gac5bfa6fb917854228a2b783f3b0b257a" name="gac5bfa6fb917854228a2b783f3b0b257a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5bfa6fb917854228a2b783f3b0b257a">&#9670;&nbsp;</a></span>AEM13920_GetTempDoneFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetTempDoneFlag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the TEMP Done IRQ flag. </p>
<p >This functions reads the TEMPDONE field of the IRQFLG1 register and sets <code>flag</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flag</td><td>TEMPDONE IRQ flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>flag</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>flag</code> is set to <code>true</code> if the temperature done IRQ flag is raised, to <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="gae25b3dc3b1b427dab507d62807343dab" name="gae25b3dc3b1b427dab507d62807343dab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae25b3dc3b1b427dab507d62807343dab">&#9670;&nbsp;</a></span>AEM13920_GetAPMDoneFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetAPMDoneFlag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the APM done IRQ flag. </p>
<p >This functions reads the APMDONE field of the IRQFLG1 register and sets <code>flag</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flag</td><td>APMDONE IRQ flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>flag</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>flag</code> is set to <code>true</code> if the APM done IRQ flag is raised, to <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="gaedc48ba39724569c3664cfc534cc4ae7" name="gaedc48ba39724569c3664cfc534cc4ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedc48ba39724569c3664cfc534cc4ae7">&#9670;&nbsp;</a></span>AEM13920_GetAPMErrFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetAPMErrFlag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the APM error IRQ flag. </p>
<p >This functions reads the APMERR field of the IRQFLG1 register and sets <code>flag</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flag</td><td>APMERR IRQ flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>flag</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>flag</code> is set to <code>true</code> if the APM error IRQ flag is raised, to <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="ga3e0379f86dc35d0c9891dd9d5421d6a2" name="ga3e0379f86dc35d0c9891dd9d5421d6a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e0379f86dc35d0c9891dd9d5421d6a2">&#9670;&nbsp;</a></span>AEM13920_GetStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetStatus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#struct_a_e_m13920___s_t_a_t_u_s__t">AEM13920_STATUS_t</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the AEM's status. </p>
<p >This function reads the STATUS0 and STATUS1 registers, and sets <code>status</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">status</td><td>AEM's status </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>status</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>status</code> is set with the AEM's status </dd></dl>

</div>
</div>
<a id="ga6e9efd1cddda0fb049cfc2f94d8d14c9" name="ga6e9efd1cddda0fb049cfc2f94d8d14c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e9efd1cddda0fb049cfc2f94d8d14c9">&#9670;&nbsp;</a></span>AEM13920_GetOverdischargeStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetOverdischargeStatus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the overdischarge status. </p>
<p >This functions reads the VOVDIS field of the STATUS0 register and sets <code>status</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">status</td><td>VOVDIS status </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>status</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>status</code> is set to <code>true</code> if the storage element's voltage is <br  />
 under the overdischarge threshold, to <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="ga09333d5d55d49d260872ebf2baf5d061" name="ga09333d5d55d49d260872ebf2baf5d061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09333d5d55d49d260872ebf2baf5d061">&#9670;&nbsp;</a></span>AEM13920_GetChargeReadyStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetChargeReadyStatus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the charge ready status. </p>
<p >This functions reads the VCHRDY field of the STATUS0 register and sets <code>status</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">status</td><td>VCHRDY status </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>status</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>status</code> is set to <code>true</code> if the storage element's voltage is <br  />
 above the charge ready threshold, to <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="ga7d34961b9367a6278a93ddbcddf183cf" name="ga7d34961b9367a6278a93ddbcddf183cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d34961b9367a6278a93ddbcddf183cf">&#9670;&nbsp;</a></span>AEM13920_GetOverchargeStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetOverchargeStatus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the overcharge status. </p>
<p >This functions reads the VOVCH field of the STATUS0 register and sets <code>status</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">status</td><td>VOVCH status </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>status</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>status</code> is set to <code>true</code> if the storage element's voltage is <br  />
 above the overcharge threshold, to <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="ga6e178f09d7bba60ad49543cd97abfd5a" name="ga6e178f09d7bba60ad49543cd97abfd5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e178f09d7bba60ad49543cd97abfd5a">&#9670;&nbsp;</a></span>AEM13920_GetSRCLowStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetSRCLowStatus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the SRC Threshold status for the selected source. </p>
<p >This functions reads the SRCxSRCLOW field of the STATUS0 register, where x is the selected source, and sets <code>status</code> accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Selected source </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">status</td><td>SRC threshold status </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>src</code> is a valid <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> </dd>
<dd>
<code>status</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>status</code> is set to <code>true</code> if the source voltage is under the defined threshold, to <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="ga0abf90472f055d5c3c46248ac3a34889" name="ga0abf90472f055d5c3c46248ac3a34889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0abf90472f055d5c3c46248ac3a34889">&#9670;&nbsp;</a></span>AEM13920_GetTempHotChargeStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetTempHotChargeStatus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the status of the hot temperature threshold (charge) </p>
<p >This functions reads the TEMPHOTCH field of the STATUS1 register and sets <code>status</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">status</td><td>TEMPHOTCH status </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>status</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>status</code> is set to <code>true</code> if the temperature is above the defined charge hot threshold, to <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="ga0d30be1886753e00f91aa23d8e43c44d" name="ga0d30be1886753e00f91aa23d8e43c44d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d30be1886753e00f91aa23d8e43c44d">&#9670;&nbsp;</a></span>AEM13920_GetTempHotDischargeStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetTempHotDischargeStatus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the status of the hot temperature threshold (discharge) </p>
<p >This functions reads the TEMPHOTDIS field of the STATUS1 register and sets <code>status</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">status</td><td>TEMPHOTDIS status </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>status</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>status</code> is set to <code>true</code> if the temperature is above the defined discharge hot threshold, to <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="ga583ba59e1e748ba4cbaaeb03c402899a" name="ga583ba59e1e748ba4cbaaeb03c402899a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga583ba59e1e748ba4cbaaeb03c402899a">&#9670;&nbsp;</a></span>AEM13920_GetTempColdChargeStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetTempColdChargeStatus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the status of the cold temperature threshold (charge) </p>
<p >This functions reads the TEMPCOLDCH field of the STATUS1 register and sets <code>status</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">status</td><td>TEMPCOLDCH status </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>status</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>status</code> is set to <code>true</code> if the temperature is below the defined charge cold threshold, to <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="ga781bb22db8e5690cdfff89d40f569a13" name="ga781bb22db8e5690cdfff89d40f569a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga781bb22db8e5690cdfff89d40f569a13">&#9670;&nbsp;</a></span>AEM13920_GetTempColdDischargeStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetTempColdDischargeStatus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the status of the cold temperature threshold (discharge) </p>
<p >This functions reads the TEMPCOLDDIS field of the STATUS1 register and sets <code>status</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">status</td><td>TEMPCOLDDIS status </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>status</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>status</code> is set to <code>true</code> if the temperature is below the defined discharge cold threshold, to <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="gaab59dc68322310fedce7d22b5c6fa7f0" name="gaab59dc68322310fedce7d22b5c6fa7f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab59dc68322310fedce7d22b5c6fa7f0">&#9670;&nbsp;</a></span>AEM13920_GetAPMSourceData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetAPMSourceData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the APM data for the specified source. </p>
<p >This functions reads the APM0SRCx, APM1SRCx and APM2SRCx registers, where x is the selected source, and sets <code>data</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Selected source </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>APM data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>src</code> is a valid <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> </dd>
<dd>
<code>data</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>In Pulse Counter mode, <code>data</code> is set with the number of pulses. </dd>
<dd>
In Power Meter mode, <code>data</code> is set with the left-shifted data from the register (DATA &lt;&lt; OFFSET). To complete the conversion to nano-Joules, refer to the formula given into the product's datasheet. </dd></dl>

</div>
</div>
<a id="ga75adee989e9522ef4db3f141a28d0af1" name="ga75adee989e9522ef4db3f141a28d0af1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75adee989e9522ef4db3f141a28d0af1">&#9670;&nbsp;</a></span>AEM13920_GetAPMBuckData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetAPMBuckData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the APM data. </p>
<p >This function reads the APM0BUCK, APM1BUCK and APM2BUCK registers, and sets <code>data</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>APM data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>data</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>In Pulse Counter mode, <code>data</code> is set with the number of pulses. </dd>
<dd>
In Power Meter mode, <code>data</code> is set with the left-shifted data from the register (DATA &lt;&lt; OFFSET). To complete the conversion to nano-Joules, refer to the formula given into the product's datasheet. </dd></dl>

</div>
</div>
<a id="gaecd265ceb6552c2ef5727da30dbe4c0b" name="gaecd265ceb6552c2ef5727da30dbe4c0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecd265ceb6552c2ef5727da30dbe4c0b">&#9670;&nbsp;</a></span>AEM13920_GetAPMErrors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetAPMErrors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#struct_a_e_m13920___a_p_m_e_r_r__t">AEM13920_APMERR_t</a> *&#160;</td>
          <td class="paramname"><em>errors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the APM errors. </p>
<p >This functions reads the APMERR register and sets <code>errors</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">errors</td><td>APM errors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>errors</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>errors</code> is set with the APM errors </dd></dl>

</div>
</div>
<a id="ga8069b4035eabd04b76c94453c5bf9850" name="ga8069b4035eabd04b76c94453c5bf9850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8069b4035eabd04b76c94453c5bf9850">&#9670;&nbsp;</a></span>AEM13920_IsAPMSourceOverflow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_IsAPMSourceOverflow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return whether an APM counter overflow occured for the specified source. </p>
<p >This function reads the SRCxOV field of the APMERR register, where x is the selected source, and sets <code>error</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Selected source </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">error</td><td>APM error </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>src</code> is a valid <a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a> </dd>
<dd>
<code>error</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>error</code> is set to true if an overflow occured for the specified source, to false otherwise </dd></dl>

</div>
</div>
<a id="ga9eeb9632af2ff4a538be9c8d7bf3d3ea" name="ga9eeb9632af2ff4a538be9c8d7bf3d3ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9eeb9632af2ff4a538be9c8d7bf3d3ea">&#9670;&nbsp;</a></span>AEM13920_IsAPMSourceCorrupted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_IsAPMSourceCorrupted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_e_m13920___common.html#ga685d69d25a21019b395b8cccc13bd3f0">AEM13920_SOURCE</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return whether the APM data for the selected source is corrupted. </p>
<p >This function reads the SRCxNVLD field of the APMERR register and sets <code>error</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">error</td><td>APM error </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>error</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>error</code> is set to true if the APM data for the selected source is corrupted, to <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="gac949ef97f362f7becce2ee11e3a62ed8" name="gac949ef97f362f7becce2ee11e3a62ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac949ef97f362f7becce2ee11e3a62ed8">&#9670;&nbsp;</a></span>AEM13920_IsAPMBuckOverflow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_IsAPMBuckOverflow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return whether an APM counter overflow occured for the buck converter. </p>
<p >This function reads the BUCKOV field of the APMERR register and sets <code>error</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">error</td><td>APM error </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>error</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>error</code> is set to true if an overflow occured, to <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="ga8d60b1539d300ac1ce5798ab71c7d878" name="ga8d60b1539d300ac1ce5798ab71c7d878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d60b1539d300ac1ce5798ab71c7d878">&#9670;&nbsp;</a></span>AEM13920_IsAPMBuckCorrupted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_IsAPMBuckCorrupted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return whether the APM data for the buck converter is corrupted. </p>
<p >This function reads the BUCKNVLD field of the APMERR register and sets <code>error</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">error</td><td>APM error </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>error</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>error</code> is set to true if the APM data for the buck converter is corrupted, to <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="gaa016914b213488da6e54747b18fdafef" name="gaa016914b213488da6e54747b18fdafef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa016914b213488da6e54747b18fdafef">&#9670;&nbsp;</a></span>AEM13920_GetThermistorZ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetThermistorZ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rdiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>rth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the thermistor's impedance. </p>
<p >This function reads the TEMP register, and sets <code>rth</code> accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rdiv</td><td>Impedance of the resistor that creates a resistive voltage divider with Rth (mOhms) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rth</td><td>Impedance of the thermistor used for the thermal monitoring feature (mOhms) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>rdiv</code> holds the impedance of the resistor Rdiv (mOhms) </dd>
<dd>
<code>rth</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>rth</code> is set with the thermistor's impedance (mOhms)</dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>rth</code> can be converted to Celsius degrees either by refering to the correspondance table that should be supplied by the thermistor's manufacturer, or by implementing the Steinhart-Hart equation. </dd>
<dd>
The user willing to work with the Steinhart-Hart equation could proceed as follows. This is an implementation of the simplified SteinhartHart equation, aka 'beta parameter equation', which returns the temperature in Celsius degrees from <code>rth</code> the thermistor's impedance, <code>t0</code> the thermistor's nominal temperature in Celsius degrees (usually 25C), <code>r0</code> the thermistor's nominal impedance and <code>beta</code> the thermistor's beta constant (kelvins): </dd>
<dd>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdint.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;math.h&gt;</span></div>
<div class="line"> </div>
<div class="line">int32_t ConvertThermZToTemp(uint32_t rth, <span class="keywordtype">float</span> t0, uint32_t r0, uint32_t beta)</div>
<div class="line">{       </div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> kelvin_conversion = 273.15f;<span class="comment">// Kelvin offset</span></div>
<div class="line">    <span class="keywordtype">float</span> t0k = t0 + kelvin_conversion; <span class="comment">// Convert t0 to Kelvins</span></div>
<div class="line">        <span class="keywordtype">float</span> numerator = ((float) beta * t0k);</div>
<div class="line">        <span class="keywordtype">float</span> denominator = ((float) beta + (t0k * logf((<span class="keywordtype">float</span>) rth / (float)r0)));</div>
<div class="line">        <span class="keywordtype">float</span> temp = (numerator / denominator);</div>
<div class="line">        <span class="keywordflow">return</span> roundf(temp - kelvin_conversion);<span class="comment">// Convert to Celsius and round</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">uint32_t ConvertTempToThermZ(<span class="keywordtype">float</span> temp, <span class="keywordtype">float</span> t0, uint32_t r0, uint32_t beta) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> kelvin_conversion = 273.15f;   <span class="comment">// Kelvin offset</span></div>
<div class="line">    <span class="keywordtype">float</span> tk = temp + kelvin_conversion;       <span class="comment">// Convert temp to Kelvin</span></div>
<div class="line">    <span class="keywordtype">float</span> t0k = t0 + kelvin_conversion;        <span class="comment">// Convert t0 to Kelvin</span></div>
<div class="line">    <span class="keywordtype">float</span> exp_term = beta * ((1.0f / tk) - (1.0f / t0k)); <span class="comment">//  * (1/T - 1/T0)</span></div>
<div class="line">    <span class="keywordtype">float</span> resistance = r0 * expf(exp_term);    <span class="comment">// R = R0 * e^(exp_term)</span></div>
<div class="line">    <span class="keywordflow">return</span> (uint32_t)roundf(resistance);       <span class="comment">// Return resistance as uint32_t</span></div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ga1f4cee89d2c024184d7dffc2d9767d48" name="ga1f4cee89d2c024184d7dffc2d9767d48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f4cee89d2c024184d7dffc2d9767d48">&#9670;&nbsp;</a></span>AEM13920_GetStorageVoltage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetStorageVoltage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>vsto</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the storage voltage. </p>
<p >This function reads the STO register, and sets <code>vsto</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vsto</td><td>Storage voltage (mV) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>vsto</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>vsto</code> is set with the storage voltage (mV) </dd></dl>

</div>
</div>
<a id="ga88f3ce80d24d35b0873e1f11163c36e2" name="ga88f3ce80d24d35b0873e1f11163c36e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88f3ce80d24d35b0873e1f11163c36e2">&#9670;&nbsp;</a></span>AEM13920_SetConfiguration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_SetConfiguration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___c_o_n_f_i_g__t">AEM13920_CONFIG_t</a> *&#160;</td>
          <td class="paramname"><em>cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the whole configuration and update the AEM accordingly. </p>
<p >This function writes the whole writable area of the register map according to the configuration specified in <code>cfg</code>, and sets the UPDATE field of the CTRL register to ensure the system registers are synchronized. If <code>blocking</code> is set to <code>true</code>, it then blocks until the synchronisation is complete</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cfg</td><td>Configuration settings </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blocking</td><td>Whether the call shall be blocking </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>cfg</code> is correctly initialized </dd>
<dd>
cfg-&gt;temp_rdiv must be correctly set (so that the temperature thresholds can be computed). </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The AEM configuration is updated according to the settings defined in <code>cfg</code> </dd>
<dd>
If <code>blocking</code> is set to <code>true</code>, the function blocks until the synchronization is complete </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <code>blocking</code> is not set to true, the function does not block, and the synchronization status can be monitored using the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gabda7c3d01846fc9825dcfff754770422" title="Get the I2C synchronization busy flag.">AEM13920_IsSyncingI2CConfiguration()</a> function </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The <code>cfg</code> parameter must be correctly set, as the function does not check the validity of the configuration. The user must ensure that the configuration is valid. An optimal way to do so is to use the <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#gac81ebab814f095bdd6fdf8c642c43441" title="Read the whole AEM configuration.">AEM13920_GetConfiguration()</a> function to get the current configuration, modify it, and then set it back using this function. </dd></dl>

</div>
</div>
<a id="gac81ebab814f095bdd6fdf8c642c43441" name="gac81ebab814f095bdd6fdf8c642c43441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac81ebab814f095bdd6fdf8c642c43441">&#9670;&nbsp;</a></span>AEM13920_GetConfiguration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t AEM13920_GetConfiguration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___handler__t">AEM13920_Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_a_l___a_e_m13920___a_p_i.html#struct_a_e_m13920___c_o_n_f_i_g__t">AEM13920_CONFIG_t</a> *&#160;</td>
          <td class="paramname"><em>cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the whole AEM configuration. </p>
<p >This function reads the whole configurable area of the register map and sets <code>cfg</code> accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Communication interface's required information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cfg</td><td>Configuration settings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t <a class="el" href="group___a_e_m13920___s_t_a_t_u_s___e_r_r___c_o_d_e.html">Status/Error code</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>handler</code> is not NULL </dd>
<dd>
<code>handler-&gt;i2c_cfg</code> is correctly initialized, as described in the <a class="el" href="group___a_e_m___driver___comm.html">I2C Communication interface</a> API </dd>
<dd>
<code>cfg-&gt;Rdiv</code> is correctly set (so that the temperature thresholds can be computed) </dd>
<dd>
<code>cfg</code> is not NULL </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>cfg</code> is set with information corresponding to the AEM's configuration </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.4-->
<!-- start footer part -->
<div id="nav-path" class="navpath" ><!-- id is needed for treeview function! -->
	<ul>
		<li class="footer" id="dark_toggle"></li>
		<li class="footer" id="use_pursuant_nda">Use pursuant NDA</li>
		<li class="footer" id="timestamp">Generated on Tue Feb 25 2025 17:45:18</li>
		<li class="footer" id="version"></li>
	</ul>
</div>
</body>
</html>
